/**
 * PARIS API
 * The PARIS API is based on a REST achitecture, and is using JSON as data format.<br/>PARIS API is Stateless, the server does not store any state about the client session on the server side. Statelessness ensures that each service consumer request can be treated independently by the service.<br/>Authentication against the API is done using a combination of Basic Authentication and Token based authentication or API-Keys.<br/><br/>Â©2021 NORIA AS. All Rights Reserved. PARIS is a trademark of <a href=\"http://noria.no/\" target=\"_blank\">NORIA AS</a>.
 *
 * The version of the OpenAPI document: 4.7-202112021325
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional } from '@angular/core';
import {
  HttpClient,
  HttpHeaders,
  HttpParams,
  HttpResponse,
  HttpEvent,
  HttpParameterCodec,
  HttpContext,
} from '@angular/common/http';
import { CustomHttpParameterCodec } from '../encoder';
import { Observable } from 'rxjs';

import { DocumentArchive } from '../model/models';
import { DocumentArchiveEmailHistoryParams } from '../model/models';
import { EmailHistory } from '../model/models';
import { Folder } from '../model/models';
import { SearchResultDocumentArchive } from '../model/models';
import { Signature } from '../model/models';

import { BASE_PATH, COLLECTION_FORMATS } from '../variables';
import { Configuration } from '../configuration';

@Injectable({
  providedIn: 'root',
})
export class DocumentArchiveService {
  protected basePath = 'http://localhost/noria-dev/rest';
  public defaultHeaders = new HttpHeaders();
  public configuration = new Configuration();
  public encoder: HttpParameterCodec;

  constructor(
    protected httpClient: HttpClient,
    @Optional() @Inject(BASE_PATH) basePath: string,
    @Optional() configuration: Configuration
  ) {
    if (configuration) {
      this.configuration = configuration;
    }
    if (typeof this.configuration.basePath !== 'string') {
      if (typeof basePath !== 'string') {
        basePath = this.basePath;
      }
      this.configuration.basePath = basePath;
    }
    this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
  }

  /**
   * @param consumes string[] mime-types
   * @return true: consumes contains 'multipart/form-data', false: otherwise
   */
  private canConsumeForm(consumes: string[]): boolean {
    const form = 'multipart/form-data';
    for (const consume of consumes) {
      if (form === consume) {
        return true;
      }
    }
    return false;
  }

  private addToHttpParams(
    httpParams: HttpParams,
    value: any,
    key?: string
  ): HttpParams {
    if (typeof value === 'object' && value instanceof Date === false) {
      httpParams = this.addToHttpParamsRecursive(httpParams, value);
    } else {
      httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
    }
    return httpParams;
  }

  private addToHttpParamsRecursive(
    httpParams: HttpParams,
    value?: any,
    key?: string
  ): HttpParams {
    if (value == null) {
      return httpParams;
    }

    if (typeof value === 'object') {
      if (Array.isArray(value)) {
        (value as any[]).forEach(
          (elem) =>
            (httpParams = this.addToHttpParamsRecursive(httpParams, elem, key))
        );
      } else if (value instanceof Date) {
        if (key != null) {
          httpParams = httpParams.append(
            key,
            (value as Date).toISOString().substr(0, 10)
          );
        } else {
          throw Error('key may not be null if value is Date');
        }
      } else {
        Object.keys(value).forEach(
          (k) =>
            (httpParams = this.addToHttpParamsRecursive(
              httpParams,
              value[k],
              key != null ? `${key}.${k}` : k
            ))
        );
      }
    } else if (key != null) {
      httpParams = httpParams.append(key, value);
    } else {
      throw Error('key may not be null if value is not object or array');
    }
    return httpParams;
  }

  /**
   * Add document to folder
   * @param id Folder id
   * @param documentId Document id
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public addDocumentToFolder1(
    id: number,
    documentId: number,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext }
  ): Observable<any>;
  public addDocumentToFolder1(
    id: number,
    documentId: number,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext }
  ): Observable<HttpResponse<any>>;
  public addDocumentToFolder1(
    id: number,
    documentId: number,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext }
  ): Observable<HttpEvent<any>>;
  public addDocumentToFolder1(
    id: number,
    documentId: number,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext }
  ): Observable<any> {
    if (id === null || id === undefined) {
      throw new Error(
        'Required parameter id was null or undefined when calling addDocumentToFolder1.'
      );
    }
    if (documentId === null || documentId === undefined) {
      throw new Error(
        'Required parameter documentId was null or undefined when calling addDocumentToFolder1.'
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (documentId !== undefined && documentId !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>documentId,
        'documentId'
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = [];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.post<any>(
      `${
        this.configuration.basePath
      }/documentarchive/folders/${encodeURIComponent(String(id))}/document`,
      null,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * Add new folder
   * @param entityType Supported entity type
   * @param entityKey Entity key
   * @param folderName Folder name
   * @param colorCode Color code
   * @param parentFolderId Parent folder id
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public addFolder1(
    entityType: 'CLAIM',
    entityKey: string,
    folderName: string,
    colorCode: 'BLUE_B' | 'GRAY_1' | 'GREEN_G' | 'RED_R' | 'YELLOW_Y',
    parentFolderId?: number,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<Folder>;
  public addFolder1(
    entityType: 'CLAIM',
    entityKey: string,
    folderName: string,
    colorCode: 'BLUE_B' | 'GRAY_1' | 'GREEN_G' | 'RED_R' | 'YELLOW_Y',
    parentFolderId?: number,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<Folder>>;
  public addFolder1(
    entityType: 'CLAIM',
    entityKey: string,
    folderName: string,
    colorCode: 'BLUE_B' | 'GRAY_1' | 'GREEN_G' | 'RED_R' | 'YELLOW_Y',
    parentFolderId?: number,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<Folder>>;
  public addFolder1(
    entityType: 'CLAIM',
    entityKey: string,
    folderName: string,
    colorCode: 'BLUE_B' | 'GRAY_1' | 'GREEN_G' | 'RED_R' | 'YELLOW_Y',
    parentFolderId?: number,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    if (entityType === null || entityType === undefined) {
      throw new Error(
        'Required parameter entityType was null or undefined when calling addFolder1.'
      );
    }
    if (entityKey === null || entityKey === undefined) {
      throw new Error(
        'Required parameter entityKey was null or undefined when calling addFolder1.'
      );
    }
    if (folderName === null || folderName === undefined) {
      throw new Error(
        'Required parameter folderName was null or undefined when calling addFolder1.'
      );
    }
    if (colorCode === null || colorCode === undefined) {
      throw new Error(
        'Required parameter colorCode was null or undefined when calling addFolder1.'
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (entityType !== undefined && entityType !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>entityType,
        'entityType'
      );
    }
    if (entityKey !== undefined && entityKey !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>entityKey,
        'entityKey'
      );
    }
    if (folderName !== undefined && folderName !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>folderName,
        'folderName'
      );
    }
    if (colorCode !== undefined && colorCode !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>colorCode,
        'colorCode'
      );
    }
    if (parentFolderId !== undefined && parentFolderId !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>parentFolderId,
        'parentFolderId'
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.post<Folder>(
      `${this.configuration.basePath}/documentarchive/folders`,
      null,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * Find documents that can be counter signed.
   * @param firstResult
   * @param maxResults
   * @param entityType
   * @param entityKey
   * @param entityKeys
   * @param includeCancelled
   * @param includeAttachments
   * @param excludeNotViewable
   * @param excludeCanNotView
   * @param statuses
   * @param approvalStatuses
   * @param fromDate
   * @param toDate
   * @param formTypes
   * @param excludeFormTypes
   * @param orderBy
   * @param orderByDirection
   * @param personId
   * @param fromYear
   * @param toYear
   * @param createdBy
   * @param reference
   * @param fromDocumentNumber
   * @param toDocumentNumber
   * @param electronic
   * @param attachmentType
   * @param toBeSignedBy Identifies the user that a document can be signed on behalf of.
   * @param documentSignatureStatuses Identified signature states to search for. An empty value includes all types.
   * @param folderId Search for documents in folder with the specified id. If the parameter is empty the search will simply disregard it.If the parameter has a negative value the search result will only include documents that are NOT linked to any folder
   * @param name Search for documents with name
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public counterSign(
    firstResult?: number,
    maxResults?: number,
    entityType?:
      | 'CLAIM'
      | 'INVOICE'
      | 'COVER_NOTE'
      | 'AGREEMENT'
      | 'POLICY'
      | 'PREMIUM',
    entityKey?: string,
    entityKeys?: Array<string>,
    includeCancelled?: boolean,
    includeAttachments?: boolean,
    excludeNotViewable?: boolean,
    excludeCanNotView?: boolean,
    statuses?: Array<'ACTIVE_A' | 'CANCELLED_C' | 'REPLACED_R' | 'WORK_W'>,
    approvalStatuses?: Array<
      'APPROVED_A' | 'DENIED_D' | 'NEVER_N' | 'TO_BE_APPROVED_T'
    >,
    fromDate?: string,
    toDate?: string,
    formTypes?: Array<
      | 'CTRL_PAYMENTS___'
      | 'ACCOUNT_DOC_AD'
      | 'ACCOUNT_EXPORT_AE'
      | 'AVTALEGIRO_AG'
      | 'ACCOUNT_LIST_AL'
      | 'ATTACHMENT_AT'
      | 'AD_BORD_BA'
      | 'CLOSE_BORD_BC'
      | 'CORR_BORD_BK'
      | 'CLAIM_BORD_BL'
      | 'CLAIM_ADVICE_BM'
      | 'PROV_BORD_BP'
      | 'CANCEL_BS'
      | 'ADD_BORD_BV'
      | 'CANCEL_CA'
      | 'COVER_CREW_NOTE_CC'
      | 'CREW_DISCLETTE_CD'
      | 'COVNOTE_EXTRACT_CE'
      | 'CREWLIST_GEN_CG'
      | 'CLAIM_INVOICE_CI'
      | 'CLMCTRL_CK'
      | 'COVER_NOTE_CN'
      | 'CHANGE_OBJ_CO'
      | 'CREW_SETTLEMENT_CS'
      | 'DEBIT_AGENTNOTE_DA'
      | 'COV_DECLARATION_DE'
      | 'DEDUCT_INVOICE_DI'
      | 'INVOICE_DN'
      | 'IMP_ELBORD_EB'
      | 'E_INVOICE_EI'
      | 'ELREMIT_EL'
      | 'FREIGHT_O_CERTI_FC'
      | 'SINGLE_GIRO_GI'
      | 'GIRO_NOTE_GN'
      | 'INTRST_CALC_IC'
      | 'CREDIT_ADVICE_IG'
      | 'INFO_CLAIM_IL'
      | 'INS_INFO_IN'
      | 'INFO_PREMIUM_IP'
      | 'AGREEM_LETTER_LA'
      | 'BENEFIC_LETTER_LB'
      | 'CLAIM_LETTER_LC'
      | 'CLM_ING_INV_LTR_LD'
      | 'LETTER_LE'
      | 'INSURANCELETTER_LI'
      | 'CREW_LETTER_LM'
      | 'CLAIM_PAYMLETT_LP'
      | 'LEGAL_RECOVERY_LR'
      | 'CERTIFICATE_LS'
      | 'LETTER_EXPIRE_LX'
      | 'LETTER_MORTGAAG_LY'
      | 'LETTER_SECURITY_LZ'
      | 'COASTAL_OFFER_MC'
      | 'MAIL_CONFIRMAT_ML'
      | 'MARINE_OFFER_MM'
      | 'MAIL_EML_FILE_MP'
      | 'NEW_PERSON_NP'
      | 'OCR_IMPORT_OC'
      | 'DEBIT_ADVICE_OG'
      | 'PERIODICAL_PAY_P_'
      | 'PAYMENT_ADVICE_PA'
      | 'PRES_TO_CLIENT_PC'
      | 'PERSON_DOCUMENT_PE'
      | 'PL_REMINDER_PL'
      | 'PAYMENT_PM'
      | 'PERSON_OFFER_PO'
      | 'PRINT_DRAFT_PP'
      | 'STATEMENT_PS'
      | 'TECHN_STMT_PT'
      | 'PREM_WAIVER_PW'
      | 'REQ_FOR_QUOTE_QU'
      | '_1REMINDER_R1'
      | '_2REMINDER_R2'
      | '_3REMINDER_R3'
      | '_4REMINDER_R4'
      | '_7REMINDER_R7'
      | '_8REMINDER_R8'
      | '_9REMINDER_R9'
      | 'CREDIT_NOTE_RC'
      | 'REMARK_RE'
      | 'MAX_NOTE_RM'
      | 'REMINDER_NOTE_RN'
      | 'ONLINE_NOTE_RO'
      | 'STATMENT_PREMIU_RP'
      | 'STATMENT_CLAIM_RQ'
      | 'PERSAC_LETTER_RS'
      | 'EXPIRE_REMINDER_RX'
      | 'SLIP_SL'
      | 'SYSTEM_MESSAGE_SM'
      | 'SLOW_PAYER_SP'
      | 'SYSTEM_SY'
      | 'TRIP_IMPORT_TI'
      | 'TAX_TFA_TT'
      | 'TAX_DOC_TX'
      | 'EXCEL_EXPORT_XL'
      | 'PLACEHOLDER_ZZ'
    >,
    excludeFormTypes?: Array<
      | 'CTRL_PAYMENTS___'
      | 'ACCOUNT_DOC_AD'
      | 'ACCOUNT_EXPORT_AE'
      | 'AVTALEGIRO_AG'
      | 'ACCOUNT_LIST_AL'
      | 'ATTACHMENT_AT'
      | 'AD_BORD_BA'
      | 'CLOSE_BORD_BC'
      | 'CORR_BORD_BK'
      | 'CLAIM_BORD_BL'
      | 'CLAIM_ADVICE_BM'
      | 'PROV_BORD_BP'
      | 'CANCEL_BS'
      | 'ADD_BORD_BV'
      | 'CANCEL_CA'
      | 'COVER_CREW_NOTE_CC'
      | 'CREW_DISCLETTE_CD'
      | 'COVNOTE_EXTRACT_CE'
      | 'CREWLIST_GEN_CG'
      | 'CLAIM_INVOICE_CI'
      | 'CLMCTRL_CK'
      | 'COVER_NOTE_CN'
      | 'CHANGE_OBJ_CO'
      | 'CREW_SETTLEMENT_CS'
      | 'DEBIT_AGENTNOTE_DA'
      | 'COV_DECLARATION_DE'
      | 'DEDUCT_INVOICE_DI'
      | 'INVOICE_DN'
      | 'IMP_ELBORD_EB'
      | 'E_INVOICE_EI'
      | 'ELREMIT_EL'
      | 'FREIGHT_O_CERTI_FC'
      | 'SINGLE_GIRO_GI'
      | 'GIRO_NOTE_GN'
      | 'INTRST_CALC_IC'
      | 'CREDIT_ADVICE_IG'
      | 'INFO_CLAIM_IL'
      | 'INS_INFO_IN'
      | 'INFO_PREMIUM_IP'
      | 'AGREEM_LETTER_LA'
      | 'BENEFIC_LETTER_LB'
      | 'CLAIM_LETTER_LC'
      | 'CLM_ING_INV_LTR_LD'
      | 'LETTER_LE'
      | 'INSURANCELETTER_LI'
      | 'CREW_LETTER_LM'
      | 'CLAIM_PAYMLETT_LP'
      | 'LEGAL_RECOVERY_LR'
      | 'CERTIFICATE_LS'
      | 'LETTER_EXPIRE_LX'
      | 'LETTER_MORTGAAG_LY'
      | 'LETTER_SECURITY_LZ'
      | 'COASTAL_OFFER_MC'
      | 'MAIL_CONFIRMAT_ML'
      | 'MARINE_OFFER_MM'
      | 'MAIL_EML_FILE_MP'
      | 'NEW_PERSON_NP'
      | 'OCR_IMPORT_OC'
      | 'DEBIT_ADVICE_OG'
      | 'PERIODICAL_PAY_P_'
      | 'PAYMENT_ADVICE_PA'
      | 'PRES_TO_CLIENT_PC'
      | 'PERSON_DOCUMENT_PE'
      | 'PL_REMINDER_PL'
      | 'PAYMENT_PM'
      | 'PERSON_OFFER_PO'
      | 'PRINT_DRAFT_PP'
      | 'STATEMENT_PS'
      | 'TECHN_STMT_PT'
      | 'PREM_WAIVER_PW'
      | 'REQ_FOR_QUOTE_QU'
      | '_1REMINDER_R1'
      | '_2REMINDER_R2'
      | '_3REMINDER_R3'
      | '_4REMINDER_R4'
      | '_7REMINDER_R7'
      | '_8REMINDER_R8'
      | '_9REMINDER_R9'
      | 'CREDIT_NOTE_RC'
      | 'REMARK_RE'
      | 'MAX_NOTE_RM'
      | 'REMINDER_NOTE_RN'
      | 'ONLINE_NOTE_RO'
      | 'STATMENT_PREMIU_RP'
      | 'STATMENT_CLAIM_RQ'
      | 'PERSAC_LETTER_RS'
      | 'EXPIRE_REMINDER_RX'
      | 'SLIP_SL'
      | 'SYSTEM_MESSAGE_SM'
      | 'SLOW_PAYER_SP'
      | 'SYSTEM_SY'
      | 'TRIP_IMPORT_TI'
      | 'TAX_TFA_TT'
      | 'TAX_DOC_TX'
      | 'EXCEL_EXPORT_XL'
      | 'PLACEHOLDER_ZZ'
    >,
    orderBy?:
      | 'ID'
      | 'NAME'
      | 'DISPLAY_NAME'
      | 'DESCRIPTION'
      | 'REFERENCE'
      | 'MIME_TYPE'
      | 'MIME_SUBTYPE'
      | 'STATUS'
      | 'APPROVAL_STATUS'
      | 'FORM_TYPE'
      | 'ENTITY_TYPE'
      | 'CREATED'
      | 'CREATED_BY'
      | 'YEAR'
      | 'DOCUMENT_NUMBER'
      | 'PERSON_NAME'
      | 'PERSON_ID',
    orderByDirection?: 'ASC' | 'DESC',
    personId?: string,
    fromYear?: number,
    toYear?: number,
    createdBy?: string,
    reference?: string,
    fromDocumentNumber?: number,
    toDocumentNumber?: number,
    electronic?: boolean,
    attachmentType?: 'AGREEMENT',
    toBeSignedBy?: string,
    documentSignatureStatuses?: Array<
      'SIG_NOT_REQ_N' | 'REJECTED_R' | 'SIGNED_S' | 'TO_BE_SIGNED_T'
    >,
    folderId?: number,
    name?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<SearchResultDocumentArchive>;
  public counterSign(
    firstResult?: number,
    maxResults?: number,
    entityType?:
      | 'CLAIM'
      | 'INVOICE'
      | 'COVER_NOTE'
      | 'AGREEMENT'
      | 'POLICY'
      | 'PREMIUM',
    entityKey?: string,
    entityKeys?: Array<string>,
    includeCancelled?: boolean,
    includeAttachments?: boolean,
    excludeNotViewable?: boolean,
    excludeCanNotView?: boolean,
    statuses?: Array<'ACTIVE_A' | 'CANCELLED_C' | 'REPLACED_R' | 'WORK_W'>,
    approvalStatuses?: Array<
      'APPROVED_A' | 'DENIED_D' | 'NEVER_N' | 'TO_BE_APPROVED_T'
    >,
    fromDate?: string,
    toDate?: string,
    formTypes?: Array<
      | 'CTRL_PAYMENTS___'
      | 'ACCOUNT_DOC_AD'
      | 'ACCOUNT_EXPORT_AE'
      | 'AVTALEGIRO_AG'
      | 'ACCOUNT_LIST_AL'
      | 'ATTACHMENT_AT'
      | 'AD_BORD_BA'
      | 'CLOSE_BORD_BC'
      | 'CORR_BORD_BK'
      | 'CLAIM_BORD_BL'
      | 'CLAIM_ADVICE_BM'
      | 'PROV_BORD_BP'
      | 'CANCEL_BS'
      | 'ADD_BORD_BV'
      | 'CANCEL_CA'
      | 'COVER_CREW_NOTE_CC'
      | 'CREW_DISCLETTE_CD'
      | 'COVNOTE_EXTRACT_CE'
      | 'CREWLIST_GEN_CG'
      | 'CLAIM_INVOICE_CI'
      | 'CLMCTRL_CK'
      | 'COVER_NOTE_CN'
      | 'CHANGE_OBJ_CO'
      | 'CREW_SETTLEMENT_CS'
      | 'DEBIT_AGENTNOTE_DA'
      | 'COV_DECLARATION_DE'
      | 'DEDUCT_INVOICE_DI'
      | 'INVOICE_DN'
      | 'IMP_ELBORD_EB'
      | 'E_INVOICE_EI'
      | 'ELREMIT_EL'
      | 'FREIGHT_O_CERTI_FC'
      | 'SINGLE_GIRO_GI'
      | 'GIRO_NOTE_GN'
      | 'INTRST_CALC_IC'
      | 'CREDIT_ADVICE_IG'
      | 'INFO_CLAIM_IL'
      | 'INS_INFO_IN'
      | 'INFO_PREMIUM_IP'
      | 'AGREEM_LETTER_LA'
      | 'BENEFIC_LETTER_LB'
      | 'CLAIM_LETTER_LC'
      | 'CLM_ING_INV_LTR_LD'
      | 'LETTER_LE'
      | 'INSURANCELETTER_LI'
      | 'CREW_LETTER_LM'
      | 'CLAIM_PAYMLETT_LP'
      | 'LEGAL_RECOVERY_LR'
      | 'CERTIFICATE_LS'
      | 'LETTER_EXPIRE_LX'
      | 'LETTER_MORTGAAG_LY'
      | 'LETTER_SECURITY_LZ'
      | 'COASTAL_OFFER_MC'
      | 'MAIL_CONFIRMAT_ML'
      | 'MARINE_OFFER_MM'
      | 'MAIL_EML_FILE_MP'
      | 'NEW_PERSON_NP'
      | 'OCR_IMPORT_OC'
      | 'DEBIT_ADVICE_OG'
      | 'PERIODICAL_PAY_P_'
      | 'PAYMENT_ADVICE_PA'
      | 'PRES_TO_CLIENT_PC'
      | 'PERSON_DOCUMENT_PE'
      | 'PL_REMINDER_PL'
      | 'PAYMENT_PM'
      | 'PERSON_OFFER_PO'
      | 'PRINT_DRAFT_PP'
      | 'STATEMENT_PS'
      | 'TECHN_STMT_PT'
      | 'PREM_WAIVER_PW'
      | 'REQ_FOR_QUOTE_QU'
      | '_1REMINDER_R1'
      | '_2REMINDER_R2'
      | '_3REMINDER_R3'
      | '_4REMINDER_R4'
      | '_7REMINDER_R7'
      | '_8REMINDER_R8'
      | '_9REMINDER_R9'
      | 'CREDIT_NOTE_RC'
      | 'REMARK_RE'
      | 'MAX_NOTE_RM'
      | 'REMINDER_NOTE_RN'
      | 'ONLINE_NOTE_RO'
      | 'STATMENT_PREMIU_RP'
      | 'STATMENT_CLAIM_RQ'
      | 'PERSAC_LETTER_RS'
      | 'EXPIRE_REMINDER_RX'
      | 'SLIP_SL'
      | 'SYSTEM_MESSAGE_SM'
      | 'SLOW_PAYER_SP'
      | 'SYSTEM_SY'
      | 'TRIP_IMPORT_TI'
      | 'TAX_TFA_TT'
      | 'TAX_DOC_TX'
      | 'EXCEL_EXPORT_XL'
      | 'PLACEHOLDER_ZZ'
    >,
    excludeFormTypes?: Array<
      | 'CTRL_PAYMENTS___'
      | 'ACCOUNT_DOC_AD'
      | 'ACCOUNT_EXPORT_AE'
      | 'AVTALEGIRO_AG'
      | 'ACCOUNT_LIST_AL'
      | 'ATTACHMENT_AT'
      | 'AD_BORD_BA'
      | 'CLOSE_BORD_BC'
      | 'CORR_BORD_BK'
      | 'CLAIM_BORD_BL'
      | 'CLAIM_ADVICE_BM'
      | 'PROV_BORD_BP'
      | 'CANCEL_BS'
      | 'ADD_BORD_BV'
      | 'CANCEL_CA'
      | 'COVER_CREW_NOTE_CC'
      | 'CREW_DISCLETTE_CD'
      | 'COVNOTE_EXTRACT_CE'
      | 'CREWLIST_GEN_CG'
      | 'CLAIM_INVOICE_CI'
      | 'CLMCTRL_CK'
      | 'COVER_NOTE_CN'
      | 'CHANGE_OBJ_CO'
      | 'CREW_SETTLEMENT_CS'
      | 'DEBIT_AGENTNOTE_DA'
      | 'COV_DECLARATION_DE'
      | 'DEDUCT_INVOICE_DI'
      | 'INVOICE_DN'
      | 'IMP_ELBORD_EB'
      | 'E_INVOICE_EI'
      | 'ELREMIT_EL'
      | 'FREIGHT_O_CERTI_FC'
      | 'SINGLE_GIRO_GI'
      | 'GIRO_NOTE_GN'
      | 'INTRST_CALC_IC'
      | 'CREDIT_ADVICE_IG'
      | 'INFO_CLAIM_IL'
      | 'INS_INFO_IN'
      | 'INFO_PREMIUM_IP'
      | 'AGREEM_LETTER_LA'
      | 'BENEFIC_LETTER_LB'
      | 'CLAIM_LETTER_LC'
      | 'CLM_ING_INV_LTR_LD'
      | 'LETTER_LE'
      | 'INSURANCELETTER_LI'
      | 'CREW_LETTER_LM'
      | 'CLAIM_PAYMLETT_LP'
      | 'LEGAL_RECOVERY_LR'
      | 'CERTIFICATE_LS'
      | 'LETTER_EXPIRE_LX'
      | 'LETTER_MORTGAAG_LY'
      | 'LETTER_SECURITY_LZ'
      | 'COASTAL_OFFER_MC'
      | 'MAIL_CONFIRMAT_ML'
      | 'MARINE_OFFER_MM'
      | 'MAIL_EML_FILE_MP'
      | 'NEW_PERSON_NP'
      | 'OCR_IMPORT_OC'
      | 'DEBIT_ADVICE_OG'
      | 'PERIODICAL_PAY_P_'
      | 'PAYMENT_ADVICE_PA'
      | 'PRES_TO_CLIENT_PC'
      | 'PERSON_DOCUMENT_PE'
      | 'PL_REMINDER_PL'
      | 'PAYMENT_PM'
      | 'PERSON_OFFER_PO'
      | 'PRINT_DRAFT_PP'
      | 'STATEMENT_PS'
      | 'TECHN_STMT_PT'
      | 'PREM_WAIVER_PW'
      | 'REQ_FOR_QUOTE_QU'
      | '_1REMINDER_R1'
      | '_2REMINDER_R2'
      | '_3REMINDER_R3'
      | '_4REMINDER_R4'
      | '_7REMINDER_R7'
      | '_8REMINDER_R8'
      | '_9REMINDER_R9'
      | 'CREDIT_NOTE_RC'
      | 'REMARK_RE'
      | 'MAX_NOTE_RM'
      | 'REMINDER_NOTE_RN'
      | 'ONLINE_NOTE_RO'
      | 'STATMENT_PREMIU_RP'
      | 'STATMENT_CLAIM_RQ'
      | 'PERSAC_LETTER_RS'
      | 'EXPIRE_REMINDER_RX'
      | 'SLIP_SL'
      | 'SYSTEM_MESSAGE_SM'
      | 'SLOW_PAYER_SP'
      | 'SYSTEM_SY'
      | 'TRIP_IMPORT_TI'
      | 'TAX_TFA_TT'
      | 'TAX_DOC_TX'
      | 'EXCEL_EXPORT_XL'
      | 'PLACEHOLDER_ZZ'
    >,
    orderBy?:
      | 'ID'
      | 'NAME'
      | 'DISPLAY_NAME'
      | 'DESCRIPTION'
      | 'REFERENCE'
      | 'MIME_TYPE'
      | 'MIME_SUBTYPE'
      | 'STATUS'
      | 'APPROVAL_STATUS'
      | 'FORM_TYPE'
      | 'ENTITY_TYPE'
      | 'CREATED'
      | 'CREATED_BY'
      | 'YEAR'
      | 'DOCUMENT_NUMBER'
      | 'PERSON_NAME'
      | 'PERSON_ID',
    orderByDirection?: 'ASC' | 'DESC',
    personId?: string,
    fromYear?: number,
    toYear?: number,
    createdBy?: string,
    reference?: string,
    fromDocumentNumber?: number,
    toDocumentNumber?: number,
    electronic?: boolean,
    attachmentType?: 'AGREEMENT',
    toBeSignedBy?: string,
    documentSignatureStatuses?: Array<
      'SIG_NOT_REQ_N' | 'REJECTED_R' | 'SIGNED_S' | 'TO_BE_SIGNED_T'
    >,
    folderId?: number,
    name?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<SearchResultDocumentArchive>>;
  public counterSign(
    firstResult?: number,
    maxResults?: number,
    entityType?:
      | 'CLAIM'
      | 'INVOICE'
      | 'COVER_NOTE'
      | 'AGREEMENT'
      | 'POLICY'
      | 'PREMIUM',
    entityKey?: string,
    entityKeys?: Array<string>,
    includeCancelled?: boolean,
    includeAttachments?: boolean,
    excludeNotViewable?: boolean,
    excludeCanNotView?: boolean,
    statuses?: Array<'ACTIVE_A' | 'CANCELLED_C' | 'REPLACED_R' | 'WORK_W'>,
    approvalStatuses?: Array<
      'APPROVED_A' | 'DENIED_D' | 'NEVER_N' | 'TO_BE_APPROVED_T'
    >,
    fromDate?: string,
    toDate?: string,
    formTypes?: Array<
      | 'CTRL_PAYMENTS___'
      | 'ACCOUNT_DOC_AD'
      | 'ACCOUNT_EXPORT_AE'
      | 'AVTALEGIRO_AG'
      | 'ACCOUNT_LIST_AL'
      | 'ATTACHMENT_AT'
      | 'AD_BORD_BA'
      | 'CLOSE_BORD_BC'
      | 'CORR_BORD_BK'
      | 'CLAIM_BORD_BL'
      | 'CLAIM_ADVICE_BM'
      | 'PROV_BORD_BP'
      | 'CANCEL_BS'
      | 'ADD_BORD_BV'
      | 'CANCEL_CA'
      | 'COVER_CREW_NOTE_CC'
      | 'CREW_DISCLETTE_CD'
      | 'COVNOTE_EXTRACT_CE'
      | 'CREWLIST_GEN_CG'
      | 'CLAIM_INVOICE_CI'
      | 'CLMCTRL_CK'
      | 'COVER_NOTE_CN'
      | 'CHANGE_OBJ_CO'
      | 'CREW_SETTLEMENT_CS'
      | 'DEBIT_AGENTNOTE_DA'
      | 'COV_DECLARATION_DE'
      | 'DEDUCT_INVOICE_DI'
      | 'INVOICE_DN'
      | 'IMP_ELBORD_EB'
      | 'E_INVOICE_EI'
      | 'ELREMIT_EL'
      | 'FREIGHT_O_CERTI_FC'
      | 'SINGLE_GIRO_GI'
      | 'GIRO_NOTE_GN'
      | 'INTRST_CALC_IC'
      | 'CREDIT_ADVICE_IG'
      | 'INFO_CLAIM_IL'
      | 'INS_INFO_IN'
      | 'INFO_PREMIUM_IP'
      | 'AGREEM_LETTER_LA'
      | 'BENEFIC_LETTER_LB'
      | 'CLAIM_LETTER_LC'
      | 'CLM_ING_INV_LTR_LD'
      | 'LETTER_LE'
      | 'INSURANCELETTER_LI'
      | 'CREW_LETTER_LM'
      | 'CLAIM_PAYMLETT_LP'
      | 'LEGAL_RECOVERY_LR'
      | 'CERTIFICATE_LS'
      | 'LETTER_EXPIRE_LX'
      | 'LETTER_MORTGAAG_LY'
      | 'LETTER_SECURITY_LZ'
      | 'COASTAL_OFFER_MC'
      | 'MAIL_CONFIRMAT_ML'
      | 'MARINE_OFFER_MM'
      | 'MAIL_EML_FILE_MP'
      | 'NEW_PERSON_NP'
      | 'OCR_IMPORT_OC'
      | 'DEBIT_ADVICE_OG'
      | 'PERIODICAL_PAY_P_'
      | 'PAYMENT_ADVICE_PA'
      | 'PRES_TO_CLIENT_PC'
      | 'PERSON_DOCUMENT_PE'
      | 'PL_REMINDER_PL'
      | 'PAYMENT_PM'
      | 'PERSON_OFFER_PO'
      | 'PRINT_DRAFT_PP'
      | 'STATEMENT_PS'
      | 'TECHN_STMT_PT'
      | 'PREM_WAIVER_PW'
      | 'REQ_FOR_QUOTE_QU'
      | '_1REMINDER_R1'
      | '_2REMINDER_R2'
      | '_3REMINDER_R3'
      | '_4REMINDER_R4'
      | '_7REMINDER_R7'
      | '_8REMINDER_R8'
      | '_9REMINDER_R9'
      | 'CREDIT_NOTE_RC'
      | 'REMARK_RE'
      | 'MAX_NOTE_RM'
      | 'REMINDER_NOTE_RN'
      | 'ONLINE_NOTE_RO'
      | 'STATMENT_PREMIU_RP'
      | 'STATMENT_CLAIM_RQ'
      | 'PERSAC_LETTER_RS'
      | 'EXPIRE_REMINDER_RX'
      | 'SLIP_SL'
      | 'SYSTEM_MESSAGE_SM'
      | 'SLOW_PAYER_SP'
      | 'SYSTEM_SY'
      | 'TRIP_IMPORT_TI'
      | 'TAX_TFA_TT'
      | 'TAX_DOC_TX'
      | 'EXCEL_EXPORT_XL'
      | 'PLACEHOLDER_ZZ'
    >,
    excludeFormTypes?: Array<
      | 'CTRL_PAYMENTS___'
      | 'ACCOUNT_DOC_AD'
      | 'ACCOUNT_EXPORT_AE'
      | 'AVTALEGIRO_AG'
      | 'ACCOUNT_LIST_AL'
      | 'ATTACHMENT_AT'
      | 'AD_BORD_BA'
      | 'CLOSE_BORD_BC'
      | 'CORR_BORD_BK'
      | 'CLAIM_BORD_BL'
      | 'CLAIM_ADVICE_BM'
      | 'PROV_BORD_BP'
      | 'CANCEL_BS'
      | 'ADD_BORD_BV'
      | 'CANCEL_CA'
      | 'COVER_CREW_NOTE_CC'
      | 'CREW_DISCLETTE_CD'
      | 'COVNOTE_EXTRACT_CE'
      | 'CREWLIST_GEN_CG'
      | 'CLAIM_INVOICE_CI'
      | 'CLMCTRL_CK'
      | 'COVER_NOTE_CN'
      | 'CHANGE_OBJ_CO'
      | 'CREW_SETTLEMENT_CS'
      | 'DEBIT_AGENTNOTE_DA'
      | 'COV_DECLARATION_DE'
      | 'DEDUCT_INVOICE_DI'
      | 'INVOICE_DN'
      | 'IMP_ELBORD_EB'
      | 'E_INVOICE_EI'
      | 'ELREMIT_EL'
      | 'FREIGHT_O_CERTI_FC'
      | 'SINGLE_GIRO_GI'
      | 'GIRO_NOTE_GN'
      | 'INTRST_CALC_IC'
      | 'CREDIT_ADVICE_IG'
      | 'INFO_CLAIM_IL'
      | 'INS_INFO_IN'
      | 'INFO_PREMIUM_IP'
      | 'AGREEM_LETTER_LA'
      | 'BENEFIC_LETTER_LB'
      | 'CLAIM_LETTER_LC'
      | 'CLM_ING_INV_LTR_LD'
      | 'LETTER_LE'
      | 'INSURANCELETTER_LI'
      | 'CREW_LETTER_LM'
      | 'CLAIM_PAYMLETT_LP'
      | 'LEGAL_RECOVERY_LR'
      | 'CERTIFICATE_LS'
      | 'LETTER_EXPIRE_LX'
      | 'LETTER_MORTGAAG_LY'
      | 'LETTER_SECURITY_LZ'
      | 'COASTAL_OFFER_MC'
      | 'MAIL_CONFIRMAT_ML'
      | 'MARINE_OFFER_MM'
      | 'MAIL_EML_FILE_MP'
      | 'NEW_PERSON_NP'
      | 'OCR_IMPORT_OC'
      | 'DEBIT_ADVICE_OG'
      | 'PERIODICAL_PAY_P_'
      | 'PAYMENT_ADVICE_PA'
      | 'PRES_TO_CLIENT_PC'
      | 'PERSON_DOCUMENT_PE'
      | 'PL_REMINDER_PL'
      | 'PAYMENT_PM'
      | 'PERSON_OFFER_PO'
      | 'PRINT_DRAFT_PP'
      | 'STATEMENT_PS'
      | 'TECHN_STMT_PT'
      | 'PREM_WAIVER_PW'
      | 'REQ_FOR_QUOTE_QU'
      | '_1REMINDER_R1'
      | '_2REMINDER_R2'
      | '_3REMINDER_R3'
      | '_4REMINDER_R4'
      | '_7REMINDER_R7'
      | '_8REMINDER_R8'
      | '_9REMINDER_R9'
      | 'CREDIT_NOTE_RC'
      | 'REMARK_RE'
      | 'MAX_NOTE_RM'
      | 'REMINDER_NOTE_RN'
      | 'ONLINE_NOTE_RO'
      | 'STATMENT_PREMIU_RP'
      | 'STATMENT_CLAIM_RQ'
      | 'PERSAC_LETTER_RS'
      | 'EXPIRE_REMINDER_RX'
      | 'SLIP_SL'
      | 'SYSTEM_MESSAGE_SM'
      | 'SLOW_PAYER_SP'
      | 'SYSTEM_SY'
      | 'TRIP_IMPORT_TI'
      | 'TAX_TFA_TT'
      | 'TAX_DOC_TX'
      | 'EXCEL_EXPORT_XL'
      | 'PLACEHOLDER_ZZ'
    >,
    orderBy?:
      | 'ID'
      | 'NAME'
      | 'DISPLAY_NAME'
      | 'DESCRIPTION'
      | 'REFERENCE'
      | 'MIME_TYPE'
      | 'MIME_SUBTYPE'
      | 'STATUS'
      | 'APPROVAL_STATUS'
      | 'FORM_TYPE'
      | 'ENTITY_TYPE'
      | 'CREATED'
      | 'CREATED_BY'
      | 'YEAR'
      | 'DOCUMENT_NUMBER'
      | 'PERSON_NAME'
      | 'PERSON_ID',
    orderByDirection?: 'ASC' | 'DESC',
    personId?: string,
    fromYear?: number,
    toYear?: number,
    createdBy?: string,
    reference?: string,
    fromDocumentNumber?: number,
    toDocumentNumber?: number,
    electronic?: boolean,
    attachmentType?: 'AGREEMENT',
    toBeSignedBy?: string,
    documentSignatureStatuses?: Array<
      'SIG_NOT_REQ_N' | 'REJECTED_R' | 'SIGNED_S' | 'TO_BE_SIGNED_T'
    >,
    folderId?: number,
    name?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<SearchResultDocumentArchive>>;
  public counterSign(
    firstResult?: number,
    maxResults?: number,
    entityType?:
      | 'CLAIM'
      | 'INVOICE'
      | 'COVER_NOTE'
      | 'AGREEMENT'
      | 'POLICY'
      | 'PREMIUM',
    entityKey?: string,
    entityKeys?: Array<string>,
    includeCancelled?: boolean,
    includeAttachments?: boolean,
    excludeNotViewable?: boolean,
    excludeCanNotView?: boolean,
    statuses?: Array<'ACTIVE_A' | 'CANCELLED_C' | 'REPLACED_R' | 'WORK_W'>,
    approvalStatuses?: Array<
      'APPROVED_A' | 'DENIED_D' | 'NEVER_N' | 'TO_BE_APPROVED_T'
    >,
    fromDate?: string,
    toDate?: string,
    formTypes?: Array<
      | 'CTRL_PAYMENTS___'
      | 'ACCOUNT_DOC_AD'
      | 'ACCOUNT_EXPORT_AE'
      | 'AVTALEGIRO_AG'
      | 'ACCOUNT_LIST_AL'
      | 'ATTACHMENT_AT'
      | 'AD_BORD_BA'
      | 'CLOSE_BORD_BC'
      | 'CORR_BORD_BK'
      | 'CLAIM_BORD_BL'
      | 'CLAIM_ADVICE_BM'
      | 'PROV_BORD_BP'
      | 'CANCEL_BS'
      | 'ADD_BORD_BV'
      | 'CANCEL_CA'
      | 'COVER_CREW_NOTE_CC'
      | 'CREW_DISCLETTE_CD'
      | 'COVNOTE_EXTRACT_CE'
      | 'CREWLIST_GEN_CG'
      | 'CLAIM_INVOICE_CI'
      | 'CLMCTRL_CK'
      | 'COVER_NOTE_CN'
      | 'CHANGE_OBJ_CO'
      | 'CREW_SETTLEMENT_CS'
      | 'DEBIT_AGENTNOTE_DA'
      | 'COV_DECLARATION_DE'
      | 'DEDUCT_INVOICE_DI'
      | 'INVOICE_DN'
      | 'IMP_ELBORD_EB'
      | 'E_INVOICE_EI'
      | 'ELREMIT_EL'
      | 'FREIGHT_O_CERTI_FC'
      | 'SINGLE_GIRO_GI'
      | 'GIRO_NOTE_GN'
      | 'INTRST_CALC_IC'
      | 'CREDIT_ADVICE_IG'
      | 'INFO_CLAIM_IL'
      | 'INS_INFO_IN'
      | 'INFO_PREMIUM_IP'
      | 'AGREEM_LETTER_LA'
      | 'BENEFIC_LETTER_LB'
      | 'CLAIM_LETTER_LC'
      | 'CLM_ING_INV_LTR_LD'
      | 'LETTER_LE'
      | 'INSURANCELETTER_LI'
      | 'CREW_LETTER_LM'
      | 'CLAIM_PAYMLETT_LP'
      | 'LEGAL_RECOVERY_LR'
      | 'CERTIFICATE_LS'
      | 'LETTER_EXPIRE_LX'
      | 'LETTER_MORTGAAG_LY'
      | 'LETTER_SECURITY_LZ'
      | 'COASTAL_OFFER_MC'
      | 'MAIL_CONFIRMAT_ML'
      | 'MARINE_OFFER_MM'
      | 'MAIL_EML_FILE_MP'
      | 'NEW_PERSON_NP'
      | 'OCR_IMPORT_OC'
      | 'DEBIT_ADVICE_OG'
      | 'PERIODICAL_PAY_P_'
      | 'PAYMENT_ADVICE_PA'
      | 'PRES_TO_CLIENT_PC'
      | 'PERSON_DOCUMENT_PE'
      | 'PL_REMINDER_PL'
      | 'PAYMENT_PM'
      | 'PERSON_OFFER_PO'
      | 'PRINT_DRAFT_PP'
      | 'STATEMENT_PS'
      | 'TECHN_STMT_PT'
      | 'PREM_WAIVER_PW'
      | 'REQ_FOR_QUOTE_QU'
      | '_1REMINDER_R1'
      | '_2REMINDER_R2'
      | '_3REMINDER_R3'
      | '_4REMINDER_R4'
      | '_7REMINDER_R7'
      | '_8REMINDER_R8'
      | '_9REMINDER_R9'
      | 'CREDIT_NOTE_RC'
      | 'REMARK_RE'
      | 'MAX_NOTE_RM'
      | 'REMINDER_NOTE_RN'
      | 'ONLINE_NOTE_RO'
      | 'STATMENT_PREMIU_RP'
      | 'STATMENT_CLAIM_RQ'
      | 'PERSAC_LETTER_RS'
      | 'EXPIRE_REMINDER_RX'
      | 'SLIP_SL'
      | 'SYSTEM_MESSAGE_SM'
      | 'SLOW_PAYER_SP'
      | 'SYSTEM_SY'
      | 'TRIP_IMPORT_TI'
      | 'TAX_TFA_TT'
      | 'TAX_DOC_TX'
      | 'EXCEL_EXPORT_XL'
      | 'PLACEHOLDER_ZZ'
    >,
    excludeFormTypes?: Array<
      | 'CTRL_PAYMENTS___'
      | 'ACCOUNT_DOC_AD'
      | 'ACCOUNT_EXPORT_AE'
      | 'AVTALEGIRO_AG'
      | 'ACCOUNT_LIST_AL'
      | 'ATTACHMENT_AT'
      | 'AD_BORD_BA'
      | 'CLOSE_BORD_BC'
      | 'CORR_BORD_BK'
      | 'CLAIM_BORD_BL'
      | 'CLAIM_ADVICE_BM'
      | 'PROV_BORD_BP'
      | 'CANCEL_BS'
      | 'ADD_BORD_BV'
      | 'CANCEL_CA'
      | 'COVER_CREW_NOTE_CC'
      | 'CREW_DISCLETTE_CD'
      | 'COVNOTE_EXTRACT_CE'
      | 'CREWLIST_GEN_CG'
      | 'CLAIM_INVOICE_CI'
      | 'CLMCTRL_CK'
      | 'COVER_NOTE_CN'
      | 'CHANGE_OBJ_CO'
      | 'CREW_SETTLEMENT_CS'
      | 'DEBIT_AGENTNOTE_DA'
      | 'COV_DECLARATION_DE'
      | 'DEDUCT_INVOICE_DI'
      | 'INVOICE_DN'
      | 'IMP_ELBORD_EB'
      | 'E_INVOICE_EI'
      | 'ELREMIT_EL'
      | 'FREIGHT_O_CERTI_FC'
      | 'SINGLE_GIRO_GI'
      | 'GIRO_NOTE_GN'
      | 'INTRST_CALC_IC'
      | 'CREDIT_ADVICE_IG'
      | 'INFO_CLAIM_IL'
      | 'INS_INFO_IN'
      | 'INFO_PREMIUM_IP'
      | 'AGREEM_LETTER_LA'
      | 'BENEFIC_LETTER_LB'
      | 'CLAIM_LETTER_LC'
      | 'CLM_ING_INV_LTR_LD'
      | 'LETTER_LE'
      | 'INSURANCELETTER_LI'
      | 'CREW_LETTER_LM'
      | 'CLAIM_PAYMLETT_LP'
      | 'LEGAL_RECOVERY_LR'
      | 'CERTIFICATE_LS'
      | 'LETTER_EXPIRE_LX'
      | 'LETTER_MORTGAAG_LY'
      | 'LETTER_SECURITY_LZ'
      | 'COASTAL_OFFER_MC'
      | 'MAIL_CONFIRMAT_ML'
      | 'MARINE_OFFER_MM'
      | 'MAIL_EML_FILE_MP'
      | 'NEW_PERSON_NP'
      | 'OCR_IMPORT_OC'
      | 'DEBIT_ADVICE_OG'
      | 'PERIODICAL_PAY_P_'
      | 'PAYMENT_ADVICE_PA'
      | 'PRES_TO_CLIENT_PC'
      | 'PERSON_DOCUMENT_PE'
      | 'PL_REMINDER_PL'
      | 'PAYMENT_PM'
      | 'PERSON_OFFER_PO'
      | 'PRINT_DRAFT_PP'
      | 'STATEMENT_PS'
      | 'TECHN_STMT_PT'
      | 'PREM_WAIVER_PW'
      | 'REQ_FOR_QUOTE_QU'
      | '_1REMINDER_R1'
      | '_2REMINDER_R2'
      | '_3REMINDER_R3'
      | '_4REMINDER_R4'
      | '_7REMINDER_R7'
      | '_8REMINDER_R8'
      | '_9REMINDER_R9'
      | 'CREDIT_NOTE_RC'
      | 'REMARK_RE'
      | 'MAX_NOTE_RM'
      | 'REMINDER_NOTE_RN'
      | 'ONLINE_NOTE_RO'
      | 'STATMENT_PREMIU_RP'
      | 'STATMENT_CLAIM_RQ'
      | 'PERSAC_LETTER_RS'
      | 'EXPIRE_REMINDER_RX'
      | 'SLIP_SL'
      | 'SYSTEM_MESSAGE_SM'
      | 'SLOW_PAYER_SP'
      | 'SYSTEM_SY'
      | 'TRIP_IMPORT_TI'
      | 'TAX_TFA_TT'
      | 'TAX_DOC_TX'
      | 'EXCEL_EXPORT_XL'
      | 'PLACEHOLDER_ZZ'
    >,
    orderBy?:
      | 'ID'
      | 'NAME'
      | 'DISPLAY_NAME'
      | 'DESCRIPTION'
      | 'REFERENCE'
      | 'MIME_TYPE'
      | 'MIME_SUBTYPE'
      | 'STATUS'
      | 'APPROVAL_STATUS'
      | 'FORM_TYPE'
      | 'ENTITY_TYPE'
      | 'CREATED'
      | 'CREATED_BY'
      | 'YEAR'
      | 'DOCUMENT_NUMBER'
      | 'PERSON_NAME'
      | 'PERSON_ID',
    orderByDirection?: 'ASC' | 'DESC',
    personId?: string,
    fromYear?: number,
    toYear?: number,
    createdBy?: string,
    reference?: string,
    fromDocumentNumber?: number,
    toDocumentNumber?: number,
    electronic?: boolean,
    attachmentType?: 'AGREEMENT',
    toBeSignedBy?: string,
    documentSignatureStatuses?: Array<
      'SIG_NOT_REQ_N' | 'REJECTED_R' | 'SIGNED_S' | 'TO_BE_SIGNED_T'
    >,
    folderId?: number,
    name?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (firstResult !== undefined && firstResult !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>firstResult,
        'firstResult'
      );
    }
    if (maxResults !== undefined && maxResults !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>maxResults,
        'maxResults'
      );
    }
    if (entityType !== undefined && entityType !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>entityType,
        'entityType'
      );
    }
    if (entityKey !== undefined && entityKey !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>entityKey,
        'entityKey'
      );
    }
    if (entityKeys) {
      entityKeys.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'entityKeys'
        );
      });
    }
    if (includeCancelled !== undefined && includeCancelled !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>includeCancelled,
        'includeCancelled'
      );
    }
    if (includeAttachments !== undefined && includeAttachments !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>includeAttachments,
        'includeAttachments'
      );
    }
    if (excludeNotViewable !== undefined && excludeNotViewable !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>excludeNotViewable,
        'excludeNotViewable'
      );
    }
    if (excludeCanNotView !== undefined && excludeCanNotView !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>excludeCanNotView,
        'excludeCanNotView'
      );
    }
    if (statuses) {
      statuses.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'statuses'
        );
      });
    }
    if (approvalStatuses) {
      approvalStatuses.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'approvalStatuses'
        );
      });
    }
    if (fromDate !== undefined && fromDate !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>fromDate,
        'fromDate'
      );
    }
    if (toDate !== undefined && toDate !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>toDate,
        'toDate'
      );
    }
    if (formTypes) {
      formTypes.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'formTypes'
        );
      });
    }
    if (excludeFormTypes) {
      excludeFormTypes.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'excludeFormTypes'
        );
      });
    }
    if (orderBy !== undefined && orderBy !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>orderBy,
        'orderBy'
      );
    }
    if (orderByDirection !== undefined && orderByDirection !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>orderByDirection,
        'orderByDirection'
      );
    }
    if (personId !== undefined && personId !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>personId,
        'personId'
      );
    }
    if (fromYear !== undefined && fromYear !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>fromYear,
        'fromYear'
      );
    }
    if (toYear !== undefined && toYear !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>toYear,
        'toYear'
      );
    }
    if (createdBy !== undefined && createdBy !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>createdBy,
        'createdBy'
      );
    }
    if (reference !== undefined && reference !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>reference,
        'reference'
      );
    }
    if (fromDocumentNumber !== undefined && fromDocumentNumber !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>fromDocumentNumber,
        'fromDocumentNumber'
      );
    }
    if (toDocumentNumber !== undefined && toDocumentNumber !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>toDocumentNumber,
        'toDocumentNumber'
      );
    }
    if (electronic !== undefined && electronic !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>electronic,
        'electronic'
      );
    }
    if (attachmentType !== undefined && attachmentType !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>attachmentType,
        'attachmentType'
      );
    }
    if (toBeSignedBy !== undefined && toBeSignedBy !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>toBeSignedBy,
        'toBeSignedBy'
      );
    }
    if (documentSignatureStatuses) {
      documentSignatureStatuses.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'documentSignatureStatuses'
        );
      });
    }
    if (folderId !== undefined && folderId !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>folderId,
        'folderId'
      );
    }
    if (name !== undefined && name !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>name,
        'name'
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.get<SearchResultDocumentArchive>(
      `${this.configuration.basePath}/documentarchive/countersign`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * Delete folder with the specified id
   * @param id Folder id
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public deleteFolder1(
    id: number,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext }
  ): Observable<any>;
  public deleteFolder1(
    id: number,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext }
  ): Observable<HttpResponse<any>>;
  public deleteFolder1(
    id: number,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext }
  ): Observable<HttpEvent<any>>;
  public deleteFolder1(
    id: number,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext }
  ): Observable<any> {
    if (id === null || id === undefined) {
      throw new Error(
        'Required parameter id was null or undefined when calling deleteFolder1.'
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = [];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.delete<any>(
      `${
        this.configuration.basePath
      }/documentarchive/folders/${encodeURIComponent(String(id))}`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * Retrieve documents in the specified folder
   * @param id Folder id
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public findDocumentsInFolder1(
    id: number,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<Array<DocumentArchive>>;
  public findDocumentsInFolder1(
    id: number,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<Array<DocumentArchive>>>;
  public findDocumentsInFolder1(
    id: number,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<Array<DocumentArchive>>>;
  public findDocumentsInFolder1(
    id: number,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    if (id === null || id === undefined) {
      throw new Error(
        'Required parameter id was null or undefined when calling findDocumentsInFolder1.'
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.get<Array<DocumentArchive>>(
      `${
        this.configuration.basePath
      }/documentarchive/folders/${encodeURIComponent(String(id))}/document`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * @param id
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public get6(
    id: number,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<DocumentArchive>;
  public get6(
    id: number,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<DocumentArchive>>;
  public get6(
    id: number,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<DocumentArchive>>;
  public get6(
    id: number,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    if (id === null || id === undefined) {
      throw new Error(
        'Required parameter id was null or undefined when calling get6.'
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.get<DocumentArchive>(
      `${this.configuration.basePath}/documentarchive/${encodeURIComponent(
        String(id)
      )}`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getCoSignatures(
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<Array<Signature>>;
  public getCoSignatures(
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<Array<Signature>>>;
  public getCoSignatures(
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<Array<Signature>>>;
  public getCoSignatures(
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.get<Array<Signature>>(
      `${this.configuration.basePath}/documentarchive/cosignatures`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * Count documents based on entityType, entityKey and includeCancelled
   * @param firstResult
   * @param maxResults
   * @param entityType
   * @param entityKey
   * @param entityKeys
   * @param includeCancelled
   * @param includeAttachments
   * @param excludeNotViewable
   * @param excludeCanNotView
   * @param statuses
   * @param approvalStatuses
   * @param fromDate
   * @param toDate
   * @param formTypes
   * @param excludeFormTypes
   * @param orderBy
   * @param orderByDirection
   * @param personId
   * @param fromYear
   * @param toYear
   * @param createdBy
   * @param reference
   * @param fromDocumentNumber
   * @param toDocumentNumber
   * @param electronic
   * @param attachmentType
   * @param toBeSignedBy Identifies the user that a document can be signed on behalf of.
   * @param documentSignatureStatuses Identified signature states to search for. An empty value includes all types.
   * @param folderId Search for documents in folder with the specified id. If the parameter is empty the search will simply disregard it.If the parameter has a negative value the search result will only include documents that are NOT linked to any folder
   * @param name Search for documents with name
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getCount1(
    firstResult?: number,
    maxResults?: number,
    entityType?:
      | 'CLAIM'
      | 'INVOICE'
      | 'COVER_NOTE'
      | 'AGREEMENT'
      | 'POLICY'
      | 'PREMIUM',
    entityKey?: string,
    entityKeys?: Array<string>,
    includeCancelled?: boolean,
    includeAttachments?: boolean,
    excludeNotViewable?: boolean,
    excludeCanNotView?: boolean,
    statuses?: Array<'ACTIVE_A' | 'CANCELLED_C' | 'REPLACED_R' | 'WORK_W'>,
    approvalStatuses?: Array<
      'APPROVED_A' | 'DENIED_D' | 'NEVER_N' | 'TO_BE_APPROVED_T'
    >,
    fromDate?: string,
    toDate?: string,
    formTypes?: Array<
      | 'CTRL_PAYMENTS___'
      | 'ACCOUNT_DOC_AD'
      | 'ACCOUNT_EXPORT_AE'
      | 'AVTALEGIRO_AG'
      | 'ACCOUNT_LIST_AL'
      | 'ATTACHMENT_AT'
      | 'AD_BORD_BA'
      | 'CLOSE_BORD_BC'
      | 'CORR_BORD_BK'
      | 'CLAIM_BORD_BL'
      | 'CLAIM_ADVICE_BM'
      | 'PROV_BORD_BP'
      | 'CANCEL_BS'
      | 'ADD_BORD_BV'
      | 'CANCEL_CA'
      | 'COVER_CREW_NOTE_CC'
      | 'CREW_DISCLETTE_CD'
      | 'COVNOTE_EXTRACT_CE'
      | 'CREWLIST_GEN_CG'
      | 'CLAIM_INVOICE_CI'
      | 'CLMCTRL_CK'
      | 'COVER_NOTE_CN'
      | 'CHANGE_OBJ_CO'
      | 'CREW_SETTLEMENT_CS'
      | 'DEBIT_AGENTNOTE_DA'
      | 'COV_DECLARATION_DE'
      | 'DEDUCT_INVOICE_DI'
      | 'INVOICE_DN'
      | 'IMP_ELBORD_EB'
      | 'E_INVOICE_EI'
      | 'ELREMIT_EL'
      | 'FREIGHT_O_CERTI_FC'
      | 'SINGLE_GIRO_GI'
      | 'GIRO_NOTE_GN'
      | 'INTRST_CALC_IC'
      | 'CREDIT_ADVICE_IG'
      | 'INFO_CLAIM_IL'
      | 'INS_INFO_IN'
      | 'INFO_PREMIUM_IP'
      | 'AGREEM_LETTER_LA'
      | 'BENEFIC_LETTER_LB'
      | 'CLAIM_LETTER_LC'
      | 'CLM_ING_INV_LTR_LD'
      | 'LETTER_LE'
      | 'INSURANCELETTER_LI'
      | 'CREW_LETTER_LM'
      | 'CLAIM_PAYMLETT_LP'
      | 'LEGAL_RECOVERY_LR'
      | 'CERTIFICATE_LS'
      | 'LETTER_EXPIRE_LX'
      | 'LETTER_MORTGAAG_LY'
      | 'LETTER_SECURITY_LZ'
      | 'COASTAL_OFFER_MC'
      | 'MAIL_CONFIRMAT_ML'
      | 'MARINE_OFFER_MM'
      | 'MAIL_EML_FILE_MP'
      | 'NEW_PERSON_NP'
      | 'OCR_IMPORT_OC'
      | 'DEBIT_ADVICE_OG'
      | 'PERIODICAL_PAY_P_'
      | 'PAYMENT_ADVICE_PA'
      | 'PRES_TO_CLIENT_PC'
      | 'PERSON_DOCUMENT_PE'
      | 'PL_REMINDER_PL'
      | 'PAYMENT_PM'
      | 'PERSON_OFFER_PO'
      | 'PRINT_DRAFT_PP'
      | 'STATEMENT_PS'
      | 'TECHN_STMT_PT'
      | 'PREM_WAIVER_PW'
      | 'REQ_FOR_QUOTE_QU'
      | '_1REMINDER_R1'
      | '_2REMINDER_R2'
      | '_3REMINDER_R3'
      | '_4REMINDER_R4'
      | '_7REMINDER_R7'
      | '_8REMINDER_R8'
      | '_9REMINDER_R9'
      | 'CREDIT_NOTE_RC'
      | 'REMARK_RE'
      | 'MAX_NOTE_RM'
      | 'REMINDER_NOTE_RN'
      | 'ONLINE_NOTE_RO'
      | 'STATMENT_PREMIU_RP'
      | 'STATMENT_CLAIM_RQ'
      | 'PERSAC_LETTER_RS'
      | 'EXPIRE_REMINDER_RX'
      | 'SLIP_SL'
      | 'SYSTEM_MESSAGE_SM'
      | 'SLOW_PAYER_SP'
      | 'SYSTEM_SY'
      | 'TRIP_IMPORT_TI'
      | 'TAX_TFA_TT'
      | 'TAX_DOC_TX'
      | 'EXCEL_EXPORT_XL'
      | 'PLACEHOLDER_ZZ'
    >,
    excludeFormTypes?: Array<
      | 'CTRL_PAYMENTS___'
      | 'ACCOUNT_DOC_AD'
      | 'ACCOUNT_EXPORT_AE'
      | 'AVTALEGIRO_AG'
      | 'ACCOUNT_LIST_AL'
      | 'ATTACHMENT_AT'
      | 'AD_BORD_BA'
      | 'CLOSE_BORD_BC'
      | 'CORR_BORD_BK'
      | 'CLAIM_BORD_BL'
      | 'CLAIM_ADVICE_BM'
      | 'PROV_BORD_BP'
      | 'CANCEL_BS'
      | 'ADD_BORD_BV'
      | 'CANCEL_CA'
      | 'COVER_CREW_NOTE_CC'
      | 'CREW_DISCLETTE_CD'
      | 'COVNOTE_EXTRACT_CE'
      | 'CREWLIST_GEN_CG'
      | 'CLAIM_INVOICE_CI'
      | 'CLMCTRL_CK'
      | 'COVER_NOTE_CN'
      | 'CHANGE_OBJ_CO'
      | 'CREW_SETTLEMENT_CS'
      | 'DEBIT_AGENTNOTE_DA'
      | 'COV_DECLARATION_DE'
      | 'DEDUCT_INVOICE_DI'
      | 'INVOICE_DN'
      | 'IMP_ELBORD_EB'
      | 'E_INVOICE_EI'
      | 'ELREMIT_EL'
      | 'FREIGHT_O_CERTI_FC'
      | 'SINGLE_GIRO_GI'
      | 'GIRO_NOTE_GN'
      | 'INTRST_CALC_IC'
      | 'CREDIT_ADVICE_IG'
      | 'INFO_CLAIM_IL'
      | 'INS_INFO_IN'
      | 'INFO_PREMIUM_IP'
      | 'AGREEM_LETTER_LA'
      | 'BENEFIC_LETTER_LB'
      | 'CLAIM_LETTER_LC'
      | 'CLM_ING_INV_LTR_LD'
      | 'LETTER_LE'
      | 'INSURANCELETTER_LI'
      | 'CREW_LETTER_LM'
      | 'CLAIM_PAYMLETT_LP'
      | 'LEGAL_RECOVERY_LR'
      | 'CERTIFICATE_LS'
      | 'LETTER_EXPIRE_LX'
      | 'LETTER_MORTGAAG_LY'
      | 'LETTER_SECURITY_LZ'
      | 'COASTAL_OFFER_MC'
      | 'MAIL_CONFIRMAT_ML'
      | 'MARINE_OFFER_MM'
      | 'MAIL_EML_FILE_MP'
      | 'NEW_PERSON_NP'
      | 'OCR_IMPORT_OC'
      | 'DEBIT_ADVICE_OG'
      | 'PERIODICAL_PAY_P_'
      | 'PAYMENT_ADVICE_PA'
      | 'PRES_TO_CLIENT_PC'
      | 'PERSON_DOCUMENT_PE'
      | 'PL_REMINDER_PL'
      | 'PAYMENT_PM'
      | 'PERSON_OFFER_PO'
      | 'PRINT_DRAFT_PP'
      | 'STATEMENT_PS'
      | 'TECHN_STMT_PT'
      | 'PREM_WAIVER_PW'
      | 'REQ_FOR_QUOTE_QU'
      | '_1REMINDER_R1'
      | '_2REMINDER_R2'
      | '_3REMINDER_R3'
      | '_4REMINDER_R4'
      | '_7REMINDER_R7'
      | '_8REMINDER_R8'
      | '_9REMINDER_R9'
      | 'CREDIT_NOTE_RC'
      | 'REMARK_RE'
      | 'MAX_NOTE_RM'
      | 'REMINDER_NOTE_RN'
      | 'ONLINE_NOTE_RO'
      | 'STATMENT_PREMIU_RP'
      | 'STATMENT_CLAIM_RQ'
      | 'PERSAC_LETTER_RS'
      | 'EXPIRE_REMINDER_RX'
      | 'SLIP_SL'
      | 'SYSTEM_MESSAGE_SM'
      | 'SLOW_PAYER_SP'
      | 'SYSTEM_SY'
      | 'TRIP_IMPORT_TI'
      | 'TAX_TFA_TT'
      | 'TAX_DOC_TX'
      | 'EXCEL_EXPORT_XL'
      | 'PLACEHOLDER_ZZ'
    >,
    orderBy?:
      | 'ID'
      | 'NAME'
      | 'DISPLAY_NAME'
      | 'DESCRIPTION'
      | 'REFERENCE'
      | 'MIME_TYPE'
      | 'MIME_SUBTYPE'
      | 'STATUS'
      | 'APPROVAL_STATUS'
      | 'FORM_TYPE'
      | 'ENTITY_TYPE'
      | 'CREATED'
      | 'CREATED_BY'
      | 'YEAR'
      | 'DOCUMENT_NUMBER'
      | 'PERSON_NAME'
      | 'PERSON_ID',
    orderByDirection?: 'ASC' | 'DESC',
    personId?: string,
    fromYear?: number,
    toYear?: number,
    createdBy?: string,
    reference?: string,
    fromDocumentNumber?: number,
    toDocumentNumber?: number,
    electronic?: boolean,
    attachmentType?: 'AGREEMENT',
    toBeSignedBy?: string,
    documentSignatureStatuses?: Array<
      'SIG_NOT_REQ_N' | 'REJECTED_R' | 'SIGNED_S' | 'TO_BE_SIGNED_T'
    >,
    folderId?: number,
    name?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<number>;
  public getCount1(
    firstResult?: number,
    maxResults?: number,
    entityType?:
      | 'CLAIM'
      | 'INVOICE'
      | 'COVER_NOTE'
      | 'AGREEMENT'
      | 'POLICY'
      | 'PREMIUM',
    entityKey?: string,
    entityKeys?: Array<string>,
    includeCancelled?: boolean,
    includeAttachments?: boolean,
    excludeNotViewable?: boolean,
    excludeCanNotView?: boolean,
    statuses?: Array<'ACTIVE_A' | 'CANCELLED_C' | 'REPLACED_R' | 'WORK_W'>,
    approvalStatuses?: Array<
      'APPROVED_A' | 'DENIED_D' | 'NEVER_N' | 'TO_BE_APPROVED_T'
    >,
    fromDate?: string,
    toDate?: string,
    formTypes?: Array<
      | 'CTRL_PAYMENTS___'
      | 'ACCOUNT_DOC_AD'
      | 'ACCOUNT_EXPORT_AE'
      | 'AVTALEGIRO_AG'
      | 'ACCOUNT_LIST_AL'
      | 'ATTACHMENT_AT'
      | 'AD_BORD_BA'
      | 'CLOSE_BORD_BC'
      | 'CORR_BORD_BK'
      | 'CLAIM_BORD_BL'
      | 'CLAIM_ADVICE_BM'
      | 'PROV_BORD_BP'
      | 'CANCEL_BS'
      | 'ADD_BORD_BV'
      | 'CANCEL_CA'
      | 'COVER_CREW_NOTE_CC'
      | 'CREW_DISCLETTE_CD'
      | 'COVNOTE_EXTRACT_CE'
      | 'CREWLIST_GEN_CG'
      | 'CLAIM_INVOICE_CI'
      | 'CLMCTRL_CK'
      | 'COVER_NOTE_CN'
      | 'CHANGE_OBJ_CO'
      | 'CREW_SETTLEMENT_CS'
      | 'DEBIT_AGENTNOTE_DA'
      | 'COV_DECLARATION_DE'
      | 'DEDUCT_INVOICE_DI'
      | 'INVOICE_DN'
      | 'IMP_ELBORD_EB'
      | 'E_INVOICE_EI'
      | 'ELREMIT_EL'
      | 'FREIGHT_O_CERTI_FC'
      | 'SINGLE_GIRO_GI'
      | 'GIRO_NOTE_GN'
      | 'INTRST_CALC_IC'
      | 'CREDIT_ADVICE_IG'
      | 'INFO_CLAIM_IL'
      | 'INS_INFO_IN'
      | 'INFO_PREMIUM_IP'
      | 'AGREEM_LETTER_LA'
      | 'BENEFIC_LETTER_LB'
      | 'CLAIM_LETTER_LC'
      | 'CLM_ING_INV_LTR_LD'
      | 'LETTER_LE'
      | 'INSURANCELETTER_LI'
      | 'CREW_LETTER_LM'
      | 'CLAIM_PAYMLETT_LP'
      | 'LEGAL_RECOVERY_LR'
      | 'CERTIFICATE_LS'
      | 'LETTER_EXPIRE_LX'
      | 'LETTER_MORTGAAG_LY'
      | 'LETTER_SECURITY_LZ'
      | 'COASTAL_OFFER_MC'
      | 'MAIL_CONFIRMAT_ML'
      | 'MARINE_OFFER_MM'
      | 'MAIL_EML_FILE_MP'
      | 'NEW_PERSON_NP'
      | 'OCR_IMPORT_OC'
      | 'DEBIT_ADVICE_OG'
      | 'PERIODICAL_PAY_P_'
      | 'PAYMENT_ADVICE_PA'
      | 'PRES_TO_CLIENT_PC'
      | 'PERSON_DOCUMENT_PE'
      | 'PL_REMINDER_PL'
      | 'PAYMENT_PM'
      | 'PERSON_OFFER_PO'
      | 'PRINT_DRAFT_PP'
      | 'STATEMENT_PS'
      | 'TECHN_STMT_PT'
      | 'PREM_WAIVER_PW'
      | 'REQ_FOR_QUOTE_QU'
      | '_1REMINDER_R1'
      | '_2REMINDER_R2'
      | '_3REMINDER_R3'
      | '_4REMINDER_R4'
      | '_7REMINDER_R7'
      | '_8REMINDER_R8'
      | '_9REMINDER_R9'
      | 'CREDIT_NOTE_RC'
      | 'REMARK_RE'
      | 'MAX_NOTE_RM'
      | 'REMINDER_NOTE_RN'
      | 'ONLINE_NOTE_RO'
      | 'STATMENT_PREMIU_RP'
      | 'STATMENT_CLAIM_RQ'
      | 'PERSAC_LETTER_RS'
      | 'EXPIRE_REMINDER_RX'
      | 'SLIP_SL'
      | 'SYSTEM_MESSAGE_SM'
      | 'SLOW_PAYER_SP'
      | 'SYSTEM_SY'
      | 'TRIP_IMPORT_TI'
      | 'TAX_TFA_TT'
      | 'TAX_DOC_TX'
      | 'EXCEL_EXPORT_XL'
      | 'PLACEHOLDER_ZZ'
    >,
    excludeFormTypes?: Array<
      | 'CTRL_PAYMENTS___'
      | 'ACCOUNT_DOC_AD'
      | 'ACCOUNT_EXPORT_AE'
      | 'AVTALEGIRO_AG'
      | 'ACCOUNT_LIST_AL'
      | 'ATTACHMENT_AT'
      | 'AD_BORD_BA'
      | 'CLOSE_BORD_BC'
      | 'CORR_BORD_BK'
      | 'CLAIM_BORD_BL'
      | 'CLAIM_ADVICE_BM'
      | 'PROV_BORD_BP'
      | 'CANCEL_BS'
      | 'ADD_BORD_BV'
      | 'CANCEL_CA'
      | 'COVER_CREW_NOTE_CC'
      | 'CREW_DISCLETTE_CD'
      | 'COVNOTE_EXTRACT_CE'
      | 'CREWLIST_GEN_CG'
      | 'CLAIM_INVOICE_CI'
      | 'CLMCTRL_CK'
      | 'COVER_NOTE_CN'
      | 'CHANGE_OBJ_CO'
      | 'CREW_SETTLEMENT_CS'
      | 'DEBIT_AGENTNOTE_DA'
      | 'COV_DECLARATION_DE'
      | 'DEDUCT_INVOICE_DI'
      | 'INVOICE_DN'
      | 'IMP_ELBORD_EB'
      | 'E_INVOICE_EI'
      | 'ELREMIT_EL'
      | 'FREIGHT_O_CERTI_FC'
      | 'SINGLE_GIRO_GI'
      | 'GIRO_NOTE_GN'
      | 'INTRST_CALC_IC'
      | 'CREDIT_ADVICE_IG'
      | 'INFO_CLAIM_IL'
      | 'INS_INFO_IN'
      | 'INFO_PREMIUM_IP'
      | 'AGREEM_LETTER_LA'
      | 'BENEFIC_LETTER_LB'
      | 'CLAIM_LETTER_LC'
      | 'CLM_ING_INV_LTR_LD'
      | 'LETTER_LE'
      | 'INSURANCELETTER_LI'
      | 'CREW_LETTER_LM'
      | 'CLAIM_PAYMLETT_LP'
      | 'LEGAL_RECOVERY_LR'
      | 'CERTIFICATE_LS'
      | 'LETTER_EXPIRE_LX'
      | 'LETTER_MORTGAAG_LY'
      | 'LETTER_SECURITY_LZ'
      | 'COASTAL_OFFER_MC'
      | 'MAIL_CONFIRMAT_ML'
      | 'MARINE_OFFER_MM'
      | 'MAIL_EML_FILE_MP'
      | 'NEW_PERSON_NP'
      | 'OCR_IMPORT_OC'
      | 'DEBIT_ADVICE_OG'
      | 'PERIODICAL_PAY_P_'
      | 'PAYMENT_ADVICE_PA'
      | 'PRES_TO_CLIENT_PC'
      | 'PERSON_DOCUMENT_PE'
      | 'PL_REMINDER_PL'
      | 'PAYMENT_PM'
      | 'PERSON_OFFER_PO'
      | 'PRINT_DRAFT_PP'
      | 'STATEMENT_PS'
      | 'TECHN_STMT_PT'
      | 'PREM_WAIVER_PW'
      | 'REQ_FOR_QUOTE_QU'
      | '_1REMINDER_R1'
      | '_2REMINDER_R2'
      | '_3REMINDER_R3'
      | '_4REMINDER_R4'
      | '_7REMINDER_R7'
      | '_8REMINDER_R8'
      | '_9REMINDER_R9'
      | 'CREDIT_NOTE_RC'
      | 'REMARK_RE'
      | 'MAX_NOTE_RM'
      | 'REMINDER_NOTE_RN'
      | 'ONLINE_NOTE_RO'
      | 'STATMENT_PREMIU_RP'
      | 'STATMENT_CLAIM_RQ'
      | 'PERSAC_LETTER_RS'
      | 'EXPIRE_REMINDER_RX'
      | 'SLIP_SL'
      | 'SYSTEM_MESSAGE_SM'
      | 'SLOW_PAYER_SP'
      | 'SYSTEM_SY'
      | 'TRIP_IMPORT_TI'
      | 'TAX_TFA_TT'
      | 'TAX_DOC_TX'
      | 'EXCEL_EXPORT_XL'
      | 'PLACEHOLDER_ZZ'
    >,
    orderBy?:
      | 'ID'
      | 'NAME'
      | 'DISPLAY_NAME'
      | 'DESCRIPTION'
      | 'REFERENCE'
      | 'MIME_TYPE'
      | 'MIME_SUBTYPE'
      | 'STATUS'
      | 'APPROVAL_STATUS'
      | 'FORM_TYPE'
      | 'ENTITY_TYPE'
      | 'CREATED'
      | 'CREATED_BY'
      | 'YEAR'
      | 'DOCUMENT_NUMBER'
      | 'PERSON_NAME'
      | 'PERSON_ID',
    orderByDirection?: 'ASC' | 'DESC',
    personId?: string,
    fromYear?: number,
    toYear?: number,
    createdBy?: string,
    reference?: string,
    fromDocumentNumber?: number,
    toDocumentNumber?: number,
    electronic?: boolean,
    attachmentType?: 'AGREEMENT',
    toBeSignedBy?: string,
    documentSignatureStatuses?: Array<
      'SIG_NOT_REQ_N' | 'REJECTED_R' | 'SIGNED_S' | 'TO_BE_SIGNED_T'
    >,
    folderId?: number,
    name?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<number>>;
  public getCount1(
    firstResult?: number,
    maxResults?: number,
    entityType?:
      | 'CLAIM'
      | 'INVOICE'
      | 'COVER_NOTE'
      | 'AGREEMENT'
      | 'POLICY'
      | 'PREMIUM',
    entityKey?: string,
    entityKeys?: Array<string>,
    includeCancelled?: boolean,
    includeAttachments?: boolean,
    excludeNotViewable?: boolean,
    excludeCanNotView?: boolean,
    statuses?: Array<'ACTIVE_A' | 'CANCELLED_C' | 'REPLACED_R' | 'WORK_W'>,
    approvalStatuses?: Array<
      'APPROVED_A' | 'DENIED_D' | 'NEVER_N' | 'TO_BE_APPROVED_T'
    >,
    fromDate?: string,
    toDate?: string,
    formTypes?: Array<
      | 'CTRL_PAYMENTS___'
      | 'ACCOUNT_DOC_AD'
      | 'ACCOUNT_EXPORT_AE'
      | 'AVTALEGIRO_AG'
      | 'ACCOUNT_LIST_AL'
      | 'ATTACHMENT_AT'
      | 'AD_BORD_BA'
      | 'CLOSE_BORD_BC'
      | 'CORR_BORD_BK'
      | 'CLAIM_BORD_BL'
      | 'CLAIM_ADVICE_BM'
      | 'PROV_BORD_BP'
      | 'CANCEL_BS'
      | 'ADD_BORD_BV'
      | 'CANCEL_CA'
      | 'COVER_CREW_NOTE_CC'
      | 'CREW_DISCLETTE_CD'
      | 'COVNOTE_EXTRACT_CE'
      | 'CREWLIST_GEN_CG'
      | 'CLAIM_INVOICE_CI'
      | 'CLMCTRL_CK'
      | 'COVER_NOTE_CN'
      | 'CHANGE_OBJ_CO'
      | 'CREW_SETTLEMENT_CS'
      | 'DEBIT_AGENTNOTE_DA'
      | 'COV_DECLARATION_DE'
      | 'DEDUCT_INVOICE_DI'
      | 'INVOICE_DN'
      | 'IMP_ELBORD_EB'
      | 'E_INVOICE_EI'
      | 'ELREMIT_EL'
      | 'FREIGHT_O_CERTI_FC'
      | 'SINGLE_GIRO_GI'
      | 'GIRO_NOTE_GN'
      | 'INTRST_CALC_IC'
      | 'CREDIT_ADVICE_IG'
      | 'INFO_CLAIM_IL'
      | 'INS_INFO_IN'
      | 'INFO_PREMIUM_IP'
      | 'AGREEM_LETTER_LA'
      | 'BENEFIC_LETTER_LB'
      | 'CLAIM_LETTER_LC'
      | 'CLM_ING_INV_LTR_LD'
      | 'LETTER_LE'
      | 'INSURANCELETTER_LI'
      | 'CREW_LETTER_LM'
      | 'CLAIM_PAYMLETT_LP'
      | 'LEGAL_RECOVERY_LR'
      | 'CERTIFICATE_LS'
      | 'LETTER_EXPIRE_LX'
      | 'LETTER_MORTGAAG_LY'
      | 'LETTER_SECURITY_LZ'
      | 'COASTAL_OFFER_MC'
      | 'MAIL_CONFIRMAT_ML'
      | 'MARINE_OFFER_MM'
      | 'MAIL_EML_FILE_MP'
      | 'NEW_PERSON_NP'
      | 'OCR_IMPORT_OC'
      | 'DEBIT_ADVICE_OG'
      | 'PERIODICAL_PAY_P_'
      | 'PAYMENT_ADVICE_PA'
      | 'PRES_TO_CLIENT_PC'
      | 'PERSON_DOCUMENT_PE'
      | 'PL_REMINDER_PL'
      | 'PAYMENT_PM'
      | 'PERSON_OFFER_PO'
      | 'PRINT_DRAFT_PP'
      | 'STATEMENT_PS'
      | 'TECHN_STMT_PT'
      | 'PREM_WAIVER_PW'
      | 'REQ_FOR_QUOTE_QU'
      | '_1REMINDER_R1'
      | '_2REMINDER_R2'
      | '_3REMINDER_R3'
      | '_4REMINDER_R4'
      | '_7REMINDER_R7'
      | '_8REMINDER_R8'
      | '_9REMINDER_R9'
      | 'CREDIT_NOTE_RC'
      | 'REMARK_RE'
      | 'MAX_NOTE_RM'
      | 'REMINDER_NOTE_RN'
      | 'ONLINE_NOTE_RO'
      | 'STATMENT_PREMIU_RP'
      | 'STATMENT_CLAIM_RQ'
      | 'PERSAC_LETTER_RS'
      | 'EXPIRE_REMINDER_RX'
      | 'SLIP_SL'
      | 'SYSTEM_MESSAGE_SM'
      | 'SLOW_PAYER_SP'
      | 'SYSTEM_SY'
      | 'TRIP_IMPORT_TI'
      | 'TAX_TFA_TT'
      | 'TAX_DOC_TX'
      | 'EXCEL_EXPORT_XL'
      | 'PLACEHOLDER_ZZ'
    >,
    excludeFormTypes?: Array<
      | 'CTRL_PAYMENTS___'
      | 'ACCOUNT_DOC_AD'
      | 'ACCOUNT_EXPORT_AE'
      | 'AVTALEGIRO_AG'
      | 'ACCOUNT_LIST_AL'
      | 'ATTACHMENT_AT'
      | 'AD_BORD_BA'
      | 'CLOSE_BORD_BC'
      | 'CORR_BORD_BK'
      | 'CLAIM_BORD_BL'
      | 'CLAIM_ADVICE_BM'
      | 'PROV_BORD_BP'
      | 'CANCEL_BS'
      | 'ADD_BORD_BV'
      | 'CANCEL_CA'
      | 'COVER_CREW_NOTE_CC'
      | 'CREW_DISCLETTE_CD'
      | 'COVNOTE_EXTRACT_CE'
      | 'CREWLIST_GEN_CG'
      | 'CLAIM_INVOICE_CI'
      | 'CLMCTRL_CK'
      | 'COVER_NOTE_CN'
      | 'CHANGE_OBJ_CO'
      | 'CREW_SETTLEMENT_CS'
      | 'DEBIT_AGENTNOTE_DA'
      | 'COV_DECLARATION_DE'
      | 'DEDUCT_INVOICE_DI'
      | 'INVOICE_DN'
      | 'IMP_ELBORD_EB'
      | 'E_INVOICE_EI'
      | 'ELREMIT_EL'
      | 'FREIGHT_O_CERTI_FC'
      | 'SINGLE_GIRO_GI'
      | 'GIRO_NOTE_GN'
      | 'INTRST_CALC_IC'
      | 'CREDIT_ADVICE_IG'
      | 'INFO_CLAIM_IL'
      | 'INS_INFO_IN'
      | 'INFO_PREMIUM_IP'
      | 'AGREEM_LETTER_LA'
      | 'BENEFIC_LETTER_LB'
      | 'CLAIM_LETTER_LC'
      | 'CLM_ING_INV_LTR_LD'
      | 'LETTER_LE'
      | 'INSURANCELETTER_LI'
      | 'CREW_LETTER_LM'
      | 'CLAIM_PAYMLETT_LP'
      | 'LEGAL_RECOVERY_LR'
      | 'CERTIFICATE_LS'
      | 'LETTER_EXPIRE_LX'
      | 'LETTER_MORTGAAG_LY'
      | 'LETTER_SECURITY_LZ'
      | 'COASTAL_OFFER_MC'
      | 'MAIL_CONFIRMAT_ML'
      | 'MARINE_OFFER_MM'
      | 'MAIL_EML_FILE_MP'
      | 'NEW_PERSON_NP'
      | 'OCR_IMPORT_OC'
      | 'DEBIT_ADVICE_OG'
      | 'PERIODICAL_PAY_P_'
      | 'PAYMENT_ADVICE_PA'
      | 'PRES_TO_CLIENT_PC'
      | 'PERSON_DOCUMENT_PE'
      | 'PL_REMINDER_PL'
      | 'PAYMENT_PM'
      | 'PERSON_OFFER_PO'
      | 'PRINT_DRAFT_PP'
      | 'STATEMENT_PS'
      | 'TECHN_STMT_PT'
      | 'PREM_WAIVER_PW'
      | 'REQ_FOR_QUOTE_QU'
      | '_1REMINDER_R1'
      | '_2REMINDER_R2'
      | '_3REMINDER_R3'
      | '_4REMINDER_R4'
      | '_7REMINDER_R7'
      | '_8REMINDER_R8'
      | '_9REMINDER_R9'
      | 'CREDIT_NOTE_RC'
      | 'REMARK_RE'
      | 'MAX_NOTE_RM'
      | 'REMINDER_NOTE_RN'
      | 'ONLINE_NOTE_RO'
      | 'STATMENT_PREMIU_RP'
      | 'STATMENT_CLAIM_RQ'
      | 'PERSAC_LETTER_RS'
      | 'EXPIRE_REMINDER_RX'
      | 'SLIP_SL'
      | 'SYSTEM_MESSAGE_SM'
      | 'SLOW_PAYER_SP'
      | 'SYSTEM_SY'
      | 'TRIP_IMPORT_TI'
      | 'TAX_TFA_TT'
      | 'TAX_DOC_TX'
      | 'EXCEL_EXPORT_XL'
      | 'PLACEHOLDER_ZZ'
    >,
    orderBy?:
      | 'ID'
      | 'NAME'
      | 'DISPLAY_NAME'
      | 'DESCRIPTION'
      | 'REFERENCE'
      | 'MIME_TYPE'
      | 'MIME_SUBTYPE'
      | 'STATUS'
      | 'APPROVAL_STATUS'
      | 'FORM_TYPE'
      | 'ENTITY_TYPE'
      | 'CREATED'
      | 'CREATED_BY'
      | 'YEAR'
      | 'DOCUMENT_NUMBER'
      | 'PERSON_NAME'
      | 'PERSON_ID',
    orderByDirection?: 'ASC' | 'DESC',
    personId?: string,
    fromYear?: number,
    toYear?: number,
    createdBy?: string,
    reference?: string,
    fromDocumentNumber?: number,
    toDocumentNumber?: number,
    electronic?: boolean,
    attachmentType?: 'AGREEMENT',
    toBeSignedBy?: string,
    documentSignatureStatuses?: Array<
      'SIG_NOT_REQ_N' | 'REJECTED_R' | 'SIGNED_S' | 'TO_BE_SIGNED_T'
    >,
    folderId?: number,
    name?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<number>>;
  public getCount1(
    firstResult?: number,
    maxResults?: number,
    entityType?:
      | 'CLAIM'
      | 'INVOICE'
      | 'COVER_NOTE'
      | 'AGREEMENT'
      | 'POLICY'
      | 'PREMIUM',
    entityKey?: string,
    entityKeys?: Array<string>,
    includeCancelled?: boolean,
    includeAttachments?: boolean,
    excludeNotViewable?: boolean,
    excludeCanNotView?: boolean,
    statuses?: Array<'ACTIVE_A' | 'CANCELLED_C' | 'REPLACED_R' | 'WORK_W'>,
    approvalStatuses?: Array<
      'APPROVED_A' | 'DENIED_D' | 'NEVER_N' | 'TO_BE_APPROVED_T'
    >,
    fromDate?: string,
    toDate?: string,
    formTypes?: Array<
      | 'CTRL_PAYMENTS___'
      | 'ACCOUNT_DOC_AD'
      | 'ACCOUNT_EXPORT_AE'
      | 'AVTALEGIRO_AG'
      | 'ACCOUNT_LIST_AL'
      | 'ATTACHMENT_AT'
      | 'AD_BORD_BA'
      | 'CLOSE_BORD_BC'
      | 'CORR_BORD_BK'
      | 'CLAIM_BORD_BL'
      | 'CLAIM_ADVICE_BM'
      | 'PROV_BORD_BP'
      | 'CANCEL_BS'
      | 'ADD_BORD_BV'
      | 'CANCEL_CA'
      | 'COVER_CREW_NOTE_CC'
      | 'CREW_DISCLETTE_CD'
      | 'COVNOTE_EXTRACT_CE'
      | 'CREWLIST_GEN_CG'
      | 'CLAIM_INVOICE_CI'
      | 'CLMCTRL_CK'
      | 'COVER_NOTE_CN'
      | 'CHANGE_OBJ_CO'
      | 'CREW_SETTLEMENT_CS'
      | 'DEBIT_AGENTNOTE_DA'
      | 'COV_DECLARATION_DE'
      | 'DEDUCT_INVOICE_DI'
      | 'INVOICE_DN'
      | 'IMP_ELBORD_EB'
      | 'E_INVOICE_EI'
      | 'ELREMIT_EL'
      | 'FREIGHT_O_CERTI_FC'
      | 'SINGLE_GIRO_GI'
      | 'GIRO_NOTE_GN'
      | 'INTRST_CALC_IC'
      | 'CREDIT_ADVICE_IG'
      | 'INFO_CLAIM_IL'
      | 'INS_INFO_IN'
      | 'INFO_PREMIUM_IP'
      | 'AGREEM_LETTER_LA'
      | 'BENEFIC_LETTER_LB'
      | 'CLAIM_LETTER_LC'
      | 'CLM_ING_INV_LTR_LD'
      | 'LETTER_LE'
      | 'INSURANCELETTER_LI'
      | 'CREW_LETTER_LM'
      | 'CLAIM_PAYMLETT_LP'
      | 'LEGAL_RECOVERY_LR'
      | 'CERTIFICATE_LS'
      | 'LETTER_EXPIRE_LX'
      | 'LETTER_MORTGAAG_LY'
      | 'LETTER_SECURITY_LZ'
      | 'COASTAL_OFFER_MC'
      | 'MAIL_CONFIRMAT_ML'
      | 'MARINE_OFFER_MM'
      | 'MAIL_EML_FILE_MP'
      | 'NEW_PERSON_NP'
      | 'OCR_IMPORT_OC'
      | 'DEBIT_ADVICE_OG'
      | 'PERIODICAL_PAY_P_'
      | 'PAYMENT_ADVICE_PA'
      | 'PRES_TO_CLIENT_PC'
      | 'PERSON_DOCUMENT_PE'
      | 'PL_REMINDER_PL'
      | 'PAYMENT_PM'
      | 'PERSON_OFFER_PO'
      | 'PRINT_DRAFT_PP'
      | 'STATEMENT_PS'
      | 'TECHN_STMT_PT'
      | 'PREM_WAIVER_PW'
      | 'REQ_FOR_QUOTE_QU'
      | '_1REMINDER_R1'
      | '_2REMINDER_R2'
      | '_3REMINDER_R3'
      | '_4REMINDER_R4'
      | '_7REMINDER_R7'
      | '_8REMINDER_R8'
      | '_9REMINDER_R9'
      | 'CREDIT_NOTE_RC'
      | 'REMARK_RE'
      | 'MAX_NOTE_RM'
      | 'REMINDER_NOTE_RN'
      | 'ONLINE_NOTE_RO'
      | 'STATMENT_PREMIU_RP'
      | 'STATMENT_CLAIM_RQ'
      | 'PERSAC_LETTER_RS'
      | 'EXPIRE_REMINDER_RX'
      | 'SLIP_SL'
      | 'SYSTEM_MESSAGE_SM'
      | 'SLOW_PAYER_SP'
      | 'SYSTEM_SY'
      | 'TRIP_IMPORT_TI'
      | 'TAX_TFA_TT'
      | 'TAX_DOC_TX'
      | 'EXCEL_EXPORT_XL'
      | 'PLACEHOLDER_ZZ'
    >,
    excludeFormTypes?: Array<
      | 'CTRL_PAYMENTS___'
      | 'ACCOUNT_DOC_AD'
      | 'ACCOUNT_EXPORT_AE'
      | 'AVTALEGIRO_AG'
      | 'ACCOUNT_LIST_AL'
      | 'ATTACHMENT_AT'
      | 'AD_BORD_BA'
      | 'CLOSE_BORD_BC'
      | 'CORR_BORD_BK'
      | 'CLAIM_BORD_BL'
      | 'CLAIM_ADVICE_BM'
      | 'PROV_BORD_BP'
      | 'CANCEL_BS'
      | 'ADD_BORD_BV'
      | 'CANCEL_CA'
      | 'COVER_CREW_NOTE_CC'
      | 'CREW_DISCLETTE_CD'
      | 'COVNOTE_EXTRACT_CE'
      | 'CREWLIST_GEN_CG'
      | 'CLAIM_INVOICE_CI'
      | 'CLMCTRL_CK'
      | 'COVER_NOTE_CN'
      | 'CHANGE_OBJ_CO'
      | 'CREW_SETTLEMENT_CS'
      | 'DEBIT_AGENTNOTE_DA'
      | 'COV_DECLARATION_DE'
      | 'DEDUCT_INVOICE_DI'
      | 'INVOICE_DN'
      | 'IMP_ELBORD_EB'
      | 'E_INVOICE_EI'
      | 'ELREMIT_EL'
      | 'FREIGHT_O_CERTI_FC'
      | 'SINGLE_GIRO_GI'
      | 'GIRO_NOTE_GN'
      | 'INTRST_CALC_IC'
      | 'CREDIT_ADVICE_IG'
      | 'INFO_CLAIM_IL'
      | 'INS_INFO_IN'
      | 'INFO_PREMIUM_IP'
      | 'AGREEM_LETTER_LA'
      | 'BENEFIC_LETTER_LB'
      | 'CLAIM_LETTER_LC'
      | 'CLM_ING_INV_LTR_LD'
      | 'LETTER_LE'
      | 'INSURANCELETTER_LI'
      | 'CREW_LETTER_LM'
      | 'CLAIM_PAYMLETT_LP'
      | 'LEGAL_RECOVERY_LR'
      | 'CERTIFICATE_LS'
      | 'LETTER_EXPIRE_LX'
      | 'LETTER_MORTGAAG_LY'
      | 'LETTER_SECURITY_LZ'
      | 'COASTAL_OFFER_MC'
      | 'MAIL_CONFIRMAT_ML'
      | 'MARINE_OFFER_MM'
      | 'MAIL_EML_FILE_MP'
      | 'NEW_PERSON_NP'
      | 'OCR_IMPORT_OC'
      | 'DEBIT_ADVICE_OG'
      | 'PERIODICAL_PAY_P_'
      | 'PAYMENT_ADVICE_PA'
      | 'PRES_TO_CLIENT_PC'
      | 'PERSON_DOCUMENT_PE'
      | 'PL_REMINDER_PL'
      | 'PAYMENT_PM'
      | 'PERSON_OFFER_PO'
      | 'PRINT_DRAFT_PP'
      | 'STATEMENT_PS'
      | 'TECHN_STMT_PT'
      | 'PREM_WAIVER_PW'
      | 'REQ_FOR_QUOTE_QU'
      | '_1REMINDER_R1'
      | '_2REMINDER_R2'
      | '_3REMINDER_R3'
      | '_4REMINDER_R4'
      | '_7REMINDER_R7'
      | '_8REMINDER_R8'
      | '_9REMINDER_R9'
      | 'CREDIT_NOTE_RC'
      | 'REMARK_RE'
      | 'MAX_NOTE_RM'
      | 'REMINDER_NOTE_RN'
      | 'ONLINE_NOTE_RO'
      | 'STATMENT_PREMIU_RP'
      | 'STATMENT_CLAIM_RQ'
      | 'PERSAC_LETTER_RS'
      | 'EXPIRE_REMINDER_RX'
      | 'SLIP_SL'
      | 'SYSTEM_MESSAGE_SM'
      | 'SLOW_PAYER_SP'
      | 'SYSTEM_SY'
      | 'TRIP_IMPORT_TI'
      | 'TAX_TFA_TT'
      | 'TAX_DOC_TX'
      | 'EXCEL_EXPORT_XL'
      | 'PLACEHOLDER_ZZ'
    >,
    orderBy?:
      | 'ID'
      | 'NAME'
      | 'DISPLAY_NAME'
      | 'DESCRIPTION'
      | 'REFERENCE'
      | 'MIME_TYPE'
      | 'MIME_SUBTYPE'
      | 'STATUS'
      | 'APPROVAL_STATUS'
      | 'FORM_TYPE'
      | 'ENTITY_TYPE'
      | 'CREATED'
      | 'CREATED_BY'
      | 'YEAR'
      | 'DOCUMENT_NUMBER'
      | 'PERSON_NAME'
      | 'PERSON_ID',
    orderByDirection?: 'ASC' | 'DESC',
    personId?: string,
    fromYear?: number,
    toYear?: number,
    createdBy?: string,
    reference?: string,
    fromDocumentNumber?: number,
    toDocumentNumber?: number,
    electronic?: boolean,
    attachmentType?: 'AGREEMENT',
    toBeSignedBy?: string,
    documentSignatureStatuses?: Array<
      'SIG_NOT_REQ_N' | 'REJECTED_R' | 'SIGNED_S' | 'TO_BE_SIGNED_T'
    >,
    folderId?: number,
    name?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (firstResult !== undefined && firstResult !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>firstResult,
        'firstResult'
      );
    }
    if (maxResults !== undefined && maxResults !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>maxResults,
        'maxResults'
      );
    }
    if (entityType !== undefined && entityType !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>entityType,
        'entityType'
      );
    }
    if (entityKey !== undefined && entityKey !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>entityKey,
        'entityKey'
      );
    }
    if (entityKeys) {
      entityKeys.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'entityKeys'
        );
      });
    }
    if (includeCancelled !== undefined && includeCancelled !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>includeCancelled,
        'includeCancelled'
      );
    }
    if (includeAttachments !== undefined && includeAttachments !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>includeAttachments,
        'includeAttachments'
      );
    }
    if (excludeNotViewable !== undefined && excludeNotViewable !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>excludeNotViewable,
        'excludeNotViewable'
      );
    }
    if (excludeCanNotView !== undefined && excludeCanNotView !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>excludeCanNotView,
        'excludeCanNotView'
      );
    }
    if (statuses) {
      statuses.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'statuses'
        );
      });
    }
    if (approvalStatuses) {
      approvalStatuses.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'approvalStatuses'
        );
      });
    }
    if (fromDate !== undefined && fromDate !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>fromDate,
        'fromDate'
      );
    }
    if (toDate !== undefined && toDate !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>toDate,
        'toDate'
      );
    }
    if (formTypes) {
      formTypes.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'formTypes'
        );
      });
    }
    if (excludeFormTypes) {
      excludeFormTypes.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'excludeFormTypes'
        );
      });
    }
    if (orderBy !== undefined && orderBy !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>orderBy,
        'orderBy'
      );
    }
    if (orderByDirection !== undefined && orderByDirection !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>orderByDirection,
        'orderByDirection'
      );
    }
    if (personId !== undefined && personId !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>personId,
        'personId'
      );
    }
    if (fromYear !== undefined && fromYear !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>fromYear,
        'fromYear'
      );
    }
    if (toYear !== undefined && toYear !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>toYear,
        'toYear'
      );
    }
    if (createdBy !== undefined && createdBy !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>createdBy,
        'createdBy'
      );
    }
    if (reference !== undefined && reference !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>reference,
        'reference'
      );
    }
    if (fromDocumentNumber !== undefined && fromDocumentNumber !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>fromDocumentNumber,
        'fromDocumentNumber'
      );
    }
    if (toDocumentNumber !== undefined && toDocumentNumber !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>toDocumentNumber,
        'toDocumentNumber'
      );
    }
    if (electronic !== undefined && electronic !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>electronic,
        'electronic'
      );
    }
    if (attachmentType !== undefined && attachmentType !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>attachmentType,
        'attachmentType'
      );
    }
    if (toBeSignedBy !== undefined && toBeSignedBy !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>toBeSignedBy,
        'toBeSignedBy'
      );
    }
    if (documentSignatureStatuses) {
      documentSignatureStatuses.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'documentSignatureStatuses'
        );
      });
    }
    if (folderId !== undefined && folderId !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>folderId,
        'folderId'
      );
    }
    if (name !== undefined && name !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>name,
        'name'
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.get<number>(
      `${this.configuration.basePath}/documentarchive/count`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * Get the binary data for a Document. Data is returned with content-type application/octet-stream
   * @param id
   * @param download
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getData1(
    id: number,
    download?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext }
  ): Observable<any>;
  public getData1(
    id: number,
    download?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext }
  ): Observable<HttpResponse<any>>;
  public getData1(
    id: number,
    download?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext }
  ): Observable<HttpEvent<any>>;
  public getData1(
    id: number,
    download?: boolean,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext }
  ): Observable<any> {
    if (id === null || id === undefined) {
      throw new Error(
        'Required parameter id was null or undefined when calling getData1.'
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (download !== undefined && download !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>download,
        'download'
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = [];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.get<any>(
      `${this.configuration.basePath}/documentarchive/${encodeURIComponent(
        String(id)
      )}/data`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * @param id
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getEmailHistory1(
    id: number,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<Array<EmailHistory>>;
  public getEmailHistory1(
    id: number,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<Array<EmailHistory>>>;
  public getEmailHistory1(
    id: number,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<Array<EmailHistory>>>;
  public getEmailHistory1(
    id: number,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    if (id === null || id === undefined) {
      throw new Error(
        'Required parameter id was null or undefined when calling getEmailHistory1.'
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.get<Array<EmailHistory>>(
      `${this.configuration.basePath}/documentarchive/${encodeURIComponent(
        String(id)
      )}/emailhistory`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * Retrieve list of folders for a specific entity type and key
   * @param entityType Supported entity type
   * @param entityKey Entity key
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getFolders1(
    entityType: 'CLAIM',
    entityKey: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<Array<Folder>>;
  public getFolders1(
    entityType: 'CLAIM',
    entityKey: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<Array<Folder>>>;
  public getFolders1(
    entityType: 'CLAIM',
    entityKey: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<Array<Folder>>>;
  public getFolders1(
    entityType: 'CLAIM',
    entityKey: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    if (entityType === null || entityType === undefined) {
      throw new Error(
        'Required parameter entityType was null or undefined when calling getFolders1.'
      );
    }
    if (entityKey === null || entityKey === undefined) {
      throw new Error(
        'Required parameter entityKey was null or undefined when calling getFolders1.'
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (entityType !== undefined && entityType !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>entityType,
        'entityType'
      );
    }
    if (entityKey !== undefined && entityKey !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>entityKey,
        'entityKey'
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.get<Array<Folder>>(
      `${this.configuration.basePath}/documentarchive/folders`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * @param body
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public logEmailHistory1(
    body?: DocumentArchiveEmailHistoryParams,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext }
  ): Observable<any>;
  public logEmailHistory1(
    body?: DocumentArchiveEmailHistoryParams,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext }
  ): Observable<HttpResponse<any>>;
  public logEmailHistory1(
    body?: DocumentArchiveEmailHistoryParams,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext }
  ): Observable<HttpEvent<any>>;
  public logEmailHistory1(
    body?: DocumentArchiveEmailHistoryParams,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = [];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Content-Type',
        httpContentTypeSelected
      );
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.post<any>(
      `${this.configuration.basePath}/documentarchive/emailhistory`,
      body,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * Move document
   * @param id Document id
   * @param folderId Folder id. If null the document will not be referenced by any folder.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public moveDocument1(
    id: number,
    folderId?: number,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext }
  ): Observable<any>;
  public moveDocument1(
    id: number,
    folderId?: number,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext }
  ): Observable<HttpResponse<any>>;
  public moveDocument1(
    id: number,
    folderId?: number,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext }
  ): Observable<HttpEvent<any>>;
  public moveDocument1(
    id: number,
    folderId?: number,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext }
  ): Observable<any> {
    if (id === null || id === undefined) {
      throw new Error(
        'Required parameter id was null or undefined when calling moveDocument1.'
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (folderId !== undefined && folderId !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>folderId,
        'folderId'
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = [];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.put<any>(
      `${
        this.configuration.basePath
      }/documentarchive/folders/${encodeURIComponent(String(id))}/document`,
      null,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * Move folder
   * @param folderId Folder id
   * @param toFolderId To folder. If target id empty it will become a root folder
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public moveFolder1(
    folderId: number,
    toFolderId?: number,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<Folder>;
  public moveFolder1(
    folderId: number,
    toFolderId?: number,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<Folder>>;
  public moveFolder1(
    folderId: number,
    toFolderId?: number,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<Folder>>;
  public moveFolder1(
    folderId: number,
    toFolderId?: number,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    if (folderId === null || folderId === undefined) {
      throw new Error(
        'Required parameter folderId was null or undefined when calling moveFolder1.'
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (folderId !== undefined && folderId !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>folderId,
        'folderId'
      );
    }
    if (toFolderId !== undefined && toFolderId !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>toFolderId,
        'toFolderId'
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.put<Folder>(
      `${this.configuration.basePath}/documentarchive/folders`,
      null,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * Reject electronically signing the specified document
   * @param id Document id
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public reject(
    id: number,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext }
  ): Observable<any>;
  public reject(
    id: number,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext }
  ): Observable<HttpResponse<any>>;
  public reject(
    id: number,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext }
  ): Observable<HttpEvent<any>>;
  public reject(
    id: number,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext }
  ): Observable<any> {
    if (id === null || id === undefined) {
      throw new Error(
        'Required parameter id was null or undefined when calling reject.'
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = [];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.post<any>(
      `${this.configuration.basePath}/documentarchive/${encodeURIComponent(
        String(id)
      )}/reject`,
      null,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * @param firstResult
   * @param maxResults
   * @param entityType
   * @param entityKey
   * @param entityKeys
   * @param includeCancelled
   * @param includeAttachments
   * @param excludeNotViewable
   * @param excludeCanNotView
   * @param statuses
   * @param approvalStatuses
   * @param fromDate
   * @param toDate
   * @param formTypes
   * @param excludeFormTypes
   * @param orderBy
   * @param orderByDirection
   * @param personId
   * @param fromYear
   * @param toYear
   * @param createdBy
   * @param reference
   * @param fromDocumentNumber
   * @param toDocumentNumber
   * @param electronic
   * @param attachmentType
   * @param toBeSignedBy Identifies the user that a document can be signed on behalf of.
   * @param documentSignatureStatuses Identified signature states to search for. An empty value includes all types.
   * @param folderId Search for documents in folder with the specified id. If the parameter is empty the search will simply disregard it.If the parameter has a negative value the search result will only include documents that are NOT linked to any folder
   * @param name Search for documents with name
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public search3(
    firstResult?: number,
    maxResults?: number,
    entityType?:
      | 'CLAIM'
      | 'INVOICE'
      | 'COVER_NOTE'
      | 'AGREEMENT'
      | 'POLICY'
      | 'PREMIUM',
    entityKey?: string,
    entityKeys?: Array<string>,
    includeCancelled?: boolean,
    includeAttachments?: boolean,
    excludeNotViewable?: boolean,
    excludeCanNotView?: boolean,
    statuses?: Array<'ACTIVE_A' | 'CANCELLED_C' | 'REPLACED_R' | 'WORK_W'>,
    approvalStatuses?: Array<
      'APPROVED_A' | 'DENIED_D' | 'NEVER_N' | 'TO_BE_APPROVED_T'
    >,
    fromDate?: string,
    toDate?: string,
    formTypes?: Array<
      | 'CTRL_PAYMENTS___'
      | 'ACCOUNT_DOC_AD'
      | 'ACCOUNT_EXPORT_AE'
      | 'AVTALEGIRO_AG'
      | 'ACCOUNT_LIST_AL'
      | 'ATTACHMENT_AT'
      | 'AD_BORD_BA'
      | 'CLOSE_BORD_BC'
      | 'CORR_BORD_BK'
      | 'CLAIM_BORD_BL'
      | 'CLAIM_ADVICE_BM'
      | 'PROV_BORD_BP'
      | 'CANCEL_BS'
      | 'ADD_BORD_BV'
      | 'CANCEL_CA'
      | 'COVER_CREW_NOTE_CC'
      | 'CREW_DISCLETTE_CD'
      | 'COVNOTE_EXTRACT_CE'
      | 'CREWLIST_GEN_CG'
      | 'CLAIM_INVOICE_CI'
      | 'CLMCTRL_CK'
      | 'COVER_NOTE_CN'
      | 'CHANGE_OBJ_CO'
      | 'CREW_SETTLEMENT_CS'
      | 'DEBIT_AGENTNOTE_DA'
      | 'COV_DECLARATION_DE'
      | 'DEDUCT_INVOICE_DI'
      | 'INVOICE_DN'
      | 'IMP_ELBORD_EB'
      | 'E_INVOICE_EI'
      | 'ELREMIT_EL'
      | 'FREIGHT_O_CERTI_FC'
      | 'SINGLE_GIRO_GI'
      | 'GIRO_NOTE_GN'
      | 'INTRST_CALC_IC'
      | 'CREDIT_ADVICE_IG'
      | 'INFO_CLAIM_IL'
      | 'INS_INFO_IN'
      | 'INFO_PREMIUM_IP'
      | 'AGREEM_LETTER_LA'
      | 'BENEFIC_LETTER_LB'
      | 'CLAIM_LETTER_LC'
      | 'CLM_ING_INV_LTR_LD'
      | 'LETTER_LE'
      | 'INSURANCELETTER_LI'
      | 'CREW_LETTER_LM'
      | 'CLAIM_PAYMLETT_LP'
      | 'LEGAL_RECOVERY_LR'
      | 'CERTIFICATE_LS'
      | 'LETTER_EXPIRE_LX'
      | 'LETTER_MORTGAAG_LY'
      | 'LETTER_SECURITY_LZ'
      | 'COASTAL_OFFER_MC'
      | 'MAIL_CONFIRMAT_ML'
      | 'MARINE_OFFER_MM'
      | 'MAIL_EML_FILE_MP'
      | 'NEW_PERSON_NP'
      | 'OCR_IMPORT_OC'
      | 'DEBIT_ADVICE_OG'
      | 'PERIODICAL_PAY_P_'
      | 'PAYMENT_ADVICE_PA'
      | 'PRES_TO_CLIENT_PC'
      | 'PERSON_DOCUMENT_PE'
      | 'PL_REMINDER_PL'
      | 'PAYMENT_PM'
      | 'PERSON_OFFER_PO'
      | 'PRINT_DRAFT_PP'
      | 'STATEMENT_PS'
      | 'TECHN_STMT_PT'
      | 'PREM_WAIVER_PW'
      | 'REQ_FOR_QUOTE_QU'
      | '_1REMINDER_R1'
      | '_2REMINDER_R2'
      | '_3REMINDER_R3'
      | '_4REMINDER_R4'
      | '_7REMINDER_R7'
      | '_8REMINDER_R8'
      | '_9REMINDER_R9'
      | 'CREDIT_NOTE_RC'
      | 'REMARK_RE'
      | 'MAX_NOTE_RM'
      | 'REMINDER_NOTE_RN'
      | 'ONLINE_NOTE_RO'
      | 'STATMENT_PREMIU_RP'
      | 'STATMENT_CLAIM_RQ'
      | 'PERSAC_LETTER_RS'
      | 'EXPIRE_REMINDER_RX'
      | 'SLIP_SL'
      | 'SYSTEM_MESSAGE_SM'
      | 'SLOW_PAYER_SP'
      | 'SYSTEM_SY'
      | 'TRIP_IMPORT_TI'
      | 'TAX_TFA_TT'
      | 'TAX_DOC_TX'
      | 'EXCEL_EXPORT_XL'
      | 'PLACEHOLDER_ZZ'
    >,
    excludeFormTypes?: Array<
      | 'CTRL_PAYMENTS___'
      | 'ACCOUNT_DOC_AD'
      | 'ACCOUNT_EXPORT_AE'
      | 'AVTALEGIRO_AG'
      | 'ACCOUNT_LIST_AL'
      | 'ATTACHMENT_AT'
      | 'AD_BORD_BA'
      | 'CLOSE_BORD_BC'
      | 'CORR_BORD_BK'
      | 'CLAIM_BORD_BL'
      | 'CLAIM_ADVICE_BM'
      | 'PROV_BORD_BP'
      | 'CANCEL_BS'
      | 'ADD_BORD_BV'
      | 'CANCEL_CA'
      | 'COVER_CREW_NOTE_CC'
      | 'CREW_DISCLETTE_CD'
      | 'COVNOTE_EXTRACT_CE'
      | 'CREWLIST_GEN_CG'
      | 'CLAIM_INVOICE_CI'
      | 'CLMCTRL_CK'
      | 'COVER_NOTE_CN'
      | 'CHANGE_OBJ_CO'
      | 'CREW_SETTLEMENT_CS'
      | 'DEBIT_AGENTNOTE_DA'
      | 'COV_DECLARATION_DE'
      | 'DEDUCT_INVOICE_DI'
      | 'INVOICE_DN'
      | 'IMP_ELBORD_EB'
      | 'E_INVOICE_EI'
      | 'ELREMIT_EL'
      | 'FREIGHT_O_CERTI_FC'
      | 'SINGLE_GIRO_GI'
      | 'GIRO_NOTE_GN'
      | 'INTRST_CALC_IC'
      | 'CREDIT_ADVICE_IG'
      | 'INFO_CLAIM_IL'
      | 'INS_INFO_IN'
      | 'INFO_PREMIUM_IP'
      | 'AGREEM_LETTER_LA'
      | 'BENEFIC_LETTER_LB'
      | 'CLAIM_LETTER_LC'
      | 'CLM_ING_INV_LTR_LD'
      | 'LETTER_LE'
      | 'INSURANCELETTER_LI'
      | 'CREW_LETTER_LM'
      | 'CLAIM_PAYMLETT_LP'
      | 'LEGAL_RECOVERY_LR'
      | 'CERTIFICATE_LS'
      | 'LETTER_EXPIRE_LX'
      | 'LETTER_MORTGAAG_LY'
      | 'LETTER_SECURITY_LZ'
      | 'COASTAL_OFFER_MC'
      | 'MAIL_CONFIRMAT_ML'
      | 'MARINE_OFFER_MM'
      | 'MAIL_EML_FILE_MP'
      | 'NEW_PERSON_NP'
      | 'OCR_IMPORT_OC'
      | 'DEBIT_ADVICE_OG'
      | 'PERIODICAL_PAY_P_'
      | 'PAYMENT_ADVICE_PA'
      | 'PRES_TO_CLIENT_PC'
      | 'PERSON_DOCUMENT_PE'
      | 'PL_REMINDER_PL'
      | 'PAYMENT_PM'
      | 'PERSON_OFFER_PO'
      | 'PRINT_DRAFT_PP'
      | 'STATEMENT_PS'
      | 'TECHN_STMT_PT'
      | 'PREM_WAIVER_PW'
      | 'REQ_FOR_QUOTE_QU'
      | '_1REMINDER_R1'
      | '_2REMINDER_R2'
      | '_3REMINDER_R3'
      | '_4REMINDER_R4'
      | '_7REMINDER_R7'
      | '_8REMINDER_R8'
      | '_9REMINDER_R9'
      | 'CREDIT_NOTE_RC'
      | 'REMARK_RE'
      | 'MAX_NOTE_RM'
      | 'REMINDER_NOTE_RN'
      | 'ONLINE_NOTE_RO'
      | 'STATMENT_PREMIU_RP'
      | 'STATMENT_CLAIM_RQ'
      | 'PERSAC_LETTER_RS'
      | 'EXPIRE_REMINDER_RX'
      | 'SLIP_SL'
      | 'SYSTEM_MESSAGE_SM'
      | 'SLOW_PAYER_SP'
      | 'SYSTEM_SY'
      | 'TRIP_IMPORT_TI'
      | 'TAX_TFA_TT'
      | 'TAX_DOC_TX'
      | 'EXCEL_EXPORT_XL'
      | 'PLACEHOLDER_ZZ'
    >,
    orderBy?:
      | 'ID'
      | 'NAME'
      | 'DISPLAY_NAME'
      | 'DESCRIPTION'
      | 'REFERENCE'
      | 'MIME_TYPE'
      | 'MIME_SUBTYPE'
      | 'STATUS'
      | 'APPROVAL_STATUS'
      | 'FORM_TYPE'
      | 'ENTITY_TYPE'
      | 'CREATED'
      | 'CREATED_BY'
      | 'YEAR'
      | 'DOCUMENT_NUMBER'
      | 'PERSON_NAME'
      | 'PERSON_ID',
    orderByDirection?: 'ASC' | 'DESC',
    personId?: string,
    fromYear?: number,
    toYear?: number,
    createdBy?: string,
    reference?: string,
    fromDocumentNumber?: number,
    toDocumentNumber?: number,
    electronic?: boolean,
    attachmentType?: 'AGREEMENT',
    toBeSignedBy?: string,
    documentSignatureStatuses?: Array<
      'SIG_NOT_REQ_N' | 'REJECTED_R' | 'SIGNED_S' | 'TO_BE_SIGNED_T'
    >,
    folderId?: number,
    name?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<SearchResultDocumentArchive>;
  public search3(
    firstResult?: number,
    maxResults?: number,
    entityType?:
      | 'CLAIM'
      | 'INVOICE'
      | 'COVER_NOTE'
      | 'AGREEMENT'
      | 'POLICY'
      | 'PREMIUM',
    entityKey?: string,
    entityKeys?: Array<string>,
    includeCancelled?: boolean,
    includeAttachments?: boolean,
    excludeNotViewable?: boolean,
    excludeCanNotView?: boolean,
    statuses?: Array<'ACTIVE_A' | 'CANCELLED_C' | 'REPLACED_R' | 'WORK_W'>,
    approvalStatuses?: Array<
      'APPROVED_A' | 'DENIED_D' | 'NEVER_N' | 'TO_BE_APPROVED_T'
    >,
    fromDate?: string,
    toDate?: string,
    formTypes?: Array<
      | 'CTRL_PAYMENTS___'
      | 'ACCOUNT_DOC_AD'
      | 'ACCOUNT_EXPORT_AE'
      | 'AVTALEGIRO_AG'
      | 'ACCOUNT_LIST_AL'
      | 'ATTACHMENT_AT'
      | 'AD_BORD_BA'
      | 'CLOSE_BORD_BC'
      | 'CORR_BORD_BK'
      | 'CLAIM_BORD_BL'
      | 'CLAIM_ADVICE_BM'
      | 'PROV_BORD_BP'
      | 'CANCEL_BS'
      | 'ADD_BORD_BV'
      | 'CANCEL_CA'
      | 'COVER_CREW_NOTE_CC'
      | 'CREW_DISCLETTE_CD'
      | 'COVNOTE_EXTRACT_CE'
      | 'CREWLIST_GEN_CG'
      | 'CLAIM_INVOICE_CI'
      | 'CLMCTRL_CK'
      | 'COVER_NOTE_CN'
      | 'CHANGE_OBJ_CO'
      | 'CREW_SETTLEMENT_CS'
      | 'DEBIT_AGENTNOTE_DA'
      | 'COV_DECLARATION_DE'
      | 'DEDUCT_INVOICE_DI'
      | 'INVOICE_DN'
      | 'IMP_ELBORD_EB'
      | 'E_INVOICE_EI'
      | 'ELREMIT_EL'
      | 'FREIGHT_O_CERTI_FC'
      | 'SINGLE_GIRO_GI'
      | 'GIRO_NOTE_GN'
      | 'INTRST_CALC_IC'
      | 'CREDIT_ADVICE_IG'
      | 'INFO_CLAIM_IL'
      | 'INS_INFO_IN'
      | 'INFO_PREMIUM_IP'
      | 'AGREEM_LETTER_LA'
      | 'BENEFIC_LETTER_LB'
      | 'CLAIM_LETTER_LC'
      | 'CLM_ING_INV_LTR_LD'
      | 'LETTER_LE'
      | 'INSURANCELETTER_LI'
      | 'CREW_LETTER_LM'
      | 'CLAIM_PAYMLETT_LP'
      | 'LEGAL_RECOVERY_LR'
      | 'CERTIFICATE_LS'
      | 'LETTER_EXPIRE_LX'
      | 'LETTER_MORTGAAG_LY'
      | 'LETTER_SECURITY_LZ'
      | 'COASTAL_OFFER_MC'
      | 'MAIL_CONFIRMAT_ML'
      | 'MARINE_OFFER_MM'
      | 'MAIL_EML_FILE_MP'
      | 'NEW_PERSON_NP'
      | 'OCR_IMPORT_OC'
      | 'DEBIT_ADVICE_OG'
      | 'PERIODICAL_PAY_P_'
      | 'PAYMENT_ADVICE_PA'
      | 'PRES_TO_CLIENT_PC'
      | 'PERSON_DOCUMENT_PE'
      | 'PL_REMINDER_PL'
      | 'PAYMENT_PM'
      | 'PERSON_OFFER_PO'
      | 'PRINT_DRAFT_PP'
      | 'STATEMENT_PS'
      | 'TECHN_STMT_PT'
      | 'PREM_WAIVER_PW'
      | 'REQ_FOR_QUOTE_QU'
      | '_1REMINDER_R1'
      | '_2REMINDER_R2'
      | '_3REMINDER_R3'
      | '_4REMINDER_R4'
      | '_7REMINDER_R7'
      | '_8REMINDER_R8'
      | '_9REMINDER_R9'
      | 'CREDIT_NOTE_RC'
      | 'REMARK_RE'
      | 'MAX_NOTE_RM'
      | 'REMINDER_NOTE_RN'
      | 'ONLINE_NOTE_RO'
      | 'STATMENT_PREMIU_RP'
      | 'STATMENT_CLAIM_RQ'
      | 'PERSAC_LETTER_RS'
      | 'EXPIRE_REMINDER_RX'
      | 'SLIP_SL'
      | 'SYSTEM_MESSAGE_SM'
      | 'SLOW_PAYER_SP'
      | 'SYSTEM_SY'
      | 'TRIP_IMPORT_TI'
      | 'TAX_TFA_TT'
      | 'TAX_DOC_TX'
      | 'EXCEL_EXPORT_XL'
      | 'PLACEHOLDER_ZZ'
    >,
    excludeFormTypes?: Array<
      | 'CTRL_PAYMENTS___'
      | 'ACCOUNT_DOC_AD'
      | 'ACCOUNT_EXPORT_AE'
      | 'AVTALEGIRO_AG'
      | 'ACCOUNT_LIST_AL'
      | 'ATTACHMENT_AT'
      | 'AD_BORD_BA'
      | 'CLOSE_BORD_BC'
      | 'CORR_BORD_BK'
      | 'CLAIM_BORD_BL'
      | 'CLAIM_ADVICE_BM'
      | 'PROV_BORD_BP'
      | 'CANCEL_BS'
      | 'ADD_BORD_BV'
      | 'CANCEL_CA'
      | 'COVER_CREW_NOTE_CC'
      | 'CREW_DISCLETTE_CD'
      | 'COVNOTE_EXTRACT_CE'
      | 'CREWLIST_GEN_CG'
      | 'CLAIM_INVOICE_CI'
      | 'CLMCTRL_CK'
      | 'COVER_NOTE_CN'
      | 'CHANGE_OBJ_CO'
      | 'CREW_SETTLEMENT_CS'
      | 'DEBIT_AGENTNOTE_DA'
      | 'COV_DECLARATION_DE'
      | 'DEDUCT_INVOICE_DI'
      | 'INVOICE_DN'
      | 'IMP_ELBORD_EB'
      | 'E_INVOICE_EI'
      | 'ELREMIT_EL'
      | 'FREIGHT_O_CERTI_FC'
      | 'SINGLE_GIRO_GI'
      | 'GIRO_NOTE_GN'
      | 'INTRST_CALC_IC'
      | 'CREDIT_ADVICE_IG'
      | 'INFO_CLAIM_IL'
      | 'INS_INFO_IN'
      | 'INFO_PREMIUM_IP'
      | 'AGREEM_LETTER_LA'
      | 'BENEFIC_LETTER_LB'
      | 'CLAIM_LETTER_LC'
      | 'CLM_ING_INV_LTR_LD'
      | 'LETTER_LE'
      | 'INSURANCELETTER_LI'
      | 'CREW_LETTER_LM'
      | 'CLAIM_PAYMLETT_LP'
      | 'LEGAL_RECOVERY_LR'
      | 'CERTIFICATE_LS'
      | 'LETTER_EXPIRE_LX'
      | 'LETTER_MORTGAAG_LY'
      | 'LETTER_SECURITY_LZ'
      | 'COASTAL_OFFER_MC'
      | 'MAIL_CONFIRMAT_ML'
      | 'MARINE_OFFER_MM'
      | 'MAIL_EML_FILE_MP'
      | 'NEW_PERSON_NP'
      | 'OCR_IMPORT_OC'
      | 'DEBIT_ADVICE_OG'
      | 'PERIODICAL_PAY_P_'
      | 'PAYMENT_ADVICE_PA'
      | 'PRES_TO_CLIENT_PC'
      | 'PERSON_DOCUMENT_PE'
      | 'PL_REMINDER_PL'
      | 'PAYMENT_PM'
      | 'PERSON_OFFER_PO'
      | 'PRINT_DRAFT_PP'
      | 'STATEMENT_PS'
      | 'TECHN_STMT_PT'
      | 'PREM_WAIVER_PW'
      | 'REQ_FOR_QUOTE_QU'
      | '_1REMINDER_R1'
      | '_2REMINDER_R2'
      | '_3REMINDER_R3'
      | '_4REMINDER_R4'
      | '_7REMINDER_R7'
      | '_8REMINDER_R8'
      | '_9REMINDER_R9'
      | 'CREDIT_NOTE_RC'
      | 'REMARK_RE'
      | 'MAX_NOTE_RM'
      | 'REMINDER_NOTE_RN'
      | 'ONLINE_NOTE_RO'
      | 'STATMENT_PREMIU_RP'
      | 'STATMENT_CLAIM_RQ'
      | 'PERSAC_LETTER_RS'
      | 'EXPIRE_REMINDER_RX'
      | 'SLIP_SL'
      | 'SYSTEM_MESSAGE_SM'
      | 'SLOW_PAYER_SP'
      | 'SYSTEM_SY'
      | 'TRIP_IMPORT_TI'
      | 'TAX_TFA_TT'
      | 'TAX_DOC_TX'
      | 'EXCEL_EXPORT_XL'
      | 'PLACEHOLDER_ZZ'
    >,
    orderBy?:
      | 'ID'
      | 'NAME'
      | 'DISPLAY_NAME'
      | 'DESCRIPTION'
      | 'REFERENCE'
      | 'MIME_TYPE'
      | 'MIME_SUBTYPE'
      | 'STATUS'
      | 'APPROVAL_STATUS'
      | 'FORM_TYPE'
      | 'ENTITY_TYPE'
      | 'CREATED'
      | 'CREATED_BY'
      | 'YEAR'
      | 'DOCUMENT_NUMBER'
      | 'PERSON_NAME'
      | 'PERSON_ID',
    orderByDirection?: 'ASC' | 'DESC',
    personId?: string,
    fromYear?: number,
    toYear?: number,
    createdBy?: string,
    reference?: string,
    fromDocumentNumber?: number,
    toDocumentNumber?: number,
    electronic?: boolean,
    attachmentType?: 'AGREEMENT',
    toBeSignedBy?: string,
    documentSignatureStatuses?: Array<
      'SIG_NOT_REQ_N' | 'REJECTED_R' | 'SIGNED_S' | 'TO_BE_SIGNED_T'
    >,
    folderId?: number,
    name?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<SearchResultDocumentArchive>>;
  public search3(
    firstResult?: number,
    maxResults?: number,
    entityType?:
      | 'CLAIM'
      | 'INVOICE'
      | 'COVER_NOTE'
      | 'AGREEMENT'
      | 'POLICY'
      | 'PREMIUM',
    entityKey?: string,
    entityKeys?: Array<string>,
    includeCancelled?: boolean,
    includeAttachments?: boolean,
    excludeNotViewable?: boolean,
    excludeCanNotView?: boolean,
    statuses?: Array<'ACTIVE_A' | 'CANCELLED_C' | 'REPLACED_R' | 'WORK_W'>,
    approvalStatuses?: Array<
      'APPROVED_A' | 'DENIED_D' | 'NEVER_N' | 'TO_BE_APPROVED_T'
    >,
    fromDate?: string,
    toDate?: string,
    formTypes?: Array<
      | 'CTRL_PAYMENTS___'
      | 'ACCOUNT_DOC_AD'
      | 'ACCOUNT_EXPORT_AE'
      | 'AVTALEGIRO_AG'
      | 'ACCOUNT_LIST_AL'
      | 'ATTACHMENT_AT'
      | 'AD_BORD_BA'
      | 'CLOSE_BORD_BC'
      | 'CORR_BORD_BK'
      | 'CLAIM_BORD_BL'
      | 'CLAIM_ADVICE_BM'
      | 'PROV_BORD_BP'
      | 'CANCEL_BS'
      | 'ADD_BORD_BV'
      | 'CANCEL_CA'
      | 'COVER_CREW_NOTE_CC'
      | 'CREW_DISCLETTE_CD'
      | 'COVNOTE_EXTRACT_CE'
      | 'CREWLIST_GEN_CG'
      | 'CLAIM_INVOICE_CI'
      | 'CLMCTRL_CK'
      | 'COVER_NOTE_CN'
      | 'CHANGE_OBJ_CO'
      | 'CREW_SETTLEMENT_CS'
      | 'DEBIT_AGENTNOTE_DA'
      | 'COV_DECLARATION_DE'
      | 'DEDUCT_INVOICE_DI'
      | 'INVOICE_DN'
      | 'IMP_ELBORD_EB'
      | 'E_INVOICE_EI'
      | 'ELREMIT_EL'
      | 'FREIGHT_O_CERTI_FC'
      | 'SINGLE_GIRO_GI'
      | 'GIRO_NOTE_GN'
      | 'INTRST_CALC_IC'
      | 'CREDIT_ADVICE_IG'
      | 'INFO_CLAIM_IL'
      | 'INS_INFO_IN'
      | 'INFO_PREMIUM_IP'
      | 'AGREEM_LETTER_LA'
      | 'BENEFIC_LETTER_LB'
      | 'CLAIM_LETTER_LC'
      | 'CLM_ING_INV_LTR_LD'
      | 'LETTER_LE'
      | 'INSURANCELETTER_LI'
      | 'CREW_LETTER_LM'
      | 'CLAIM_PAYMLETT_LP'
      | 'LEGAL_RECOVERY_LR'
      | 'CERTIFICATE_LS'
      | 'LETTER_EXPIRE_LX'
      | 'LETTER_MORTGAAG_LY'
      | 'LETTER_SECURITY_LZ'
      | 'COASTAL_OFFER_MC'
      | 'MAIL_CONFIRMAT_ML'
      | 'MARINE_OFFER_MM'
      | 'MAIL_EML_FILE_MP'
      | 'NEW_PERSON_NP'
      | 'OCR_IMPORT_OC'
      | 'DEBIT_ADVICE_OG'
      | 'PERIODICAL_PAY_P_'
      | 'PAYMENT_ADVICE_PA'
      | 'PRES_TO_CLIENT_PC'
      | 'PERSON_DOCUMENT_PE'
      | 'PL_REMINDER_PL'
      | 'PAYMENT_PM'
      | 'PERSON_OFFER_PO'
      | 'PRINT_DRAFT_PP'
      | 'STATEMENT_PS'
      | 'TECHN_STMT_PT'
      | 'PREM_WAIVER_PW'
      | 'REQ_FOR_QUOTE_QU'
      | '_1REMINDER_R1'
      | '_2REMINDER_R2'
      | '_3REMINDER_R3'
      | '_4REMINDER_R4'
      | '_7REMINDER_R7'
      | '_8REMINDER_R8'
      | '_9REMINDER_R9'
      | 'CREDIT_NOTE_RC'
      | 'REMARK_RE'
      | 'MAX_NOTE_RM'
      | 'REMINDER_NOTE_RN'
      | 'ONLINE_NOTE_RO'
      | 'STATMENT_PREMIU_RP'
      | 'STATMENT_CLAIM_RQ'
      | 'PERSAC_LETTER_RS'
      | 'EXPIRE_REMINDER_RX'
      | 'SLIP_SL'
      | 'SYSTEM_MESSAGE_SM'
      | 'SLOW_PAYER_SP'
      | 'SYSTEM_SY'
      | 'TRIP_IMPORT_TI'
      | 'TAX_TFA_TT'
      | 'TAX_DOC_TX'
      | 'EXCEL_EXPORT_XL'
      | 'PLACEHOLDER_ZZ'
    >,
    excludeFormTypes?: Array<
      | 'CTRL_PAYMENTS___'
      | 'ACCOUNT_DOC_AD'
      | 'ACCOUNT_EXPORT_AE'
      | 'AVTALEGIRO_AG'
      | 'ACCOUNT_LIST_AL'
      | 'ATTACHMENT_AT'
      | 'AD_BORD_BA'
      | 'CLOSE_BORD_BC'
      | 'CORR_BORD_BK'
      | 'CLAIM_BORD_BL'
      | 'CLAIM_ADVICE_BM'
      | 'PROV_BORD_BP'
      | 'CANCEL_BS'
      | 'ADD_BORD_BV'
      | 'CANCEL_CA'
      | 'COVER_CREW_NOTE_CC'
      | 'CREW_DISCLETTE_CD'
      | 'COVNOTE_EXTRACT_CE'
      | 'CREWLIST_GEN_CG'
      | 'CLAIM_INVOICE_CI'
      | 'CLMCTRL_CK'
      | 'COVER_NOTE_CN'
      | 'CHANGE_OBJ_CO'
      | 'CREW_SETTLEMENT_CS'
      | 'DEBIT_AGENTNOTE_DA'
      | 'COV_DECLARATION_DE'
      | 'DEDUCT_INVOICE_DI'
      | 'INVOICE_DN'
      | 'IMP_ELBORD_EB'
      | 'E_INVOICE_EI'
      | 'ELREMIT_EL'
      | 'FREIGHT_O_CERTI_FC'
      | 'SINGLE_GIRO_GI'
      | 'GIRO_NOTE_GN'
      | 'INTRST_CALC_IC'
      | 'CREDIT_ADVICE_IG'
      | 'INFO_CLAIM_IL'
      | 'INS_INFO_IN'
      | 'INFO_PREMIUM_IP'
      | 'AGREEM_LETTER_LA'
      | 'BENEFIC_LETTER_LB'
      | 'CLAIM_LETTER_LC'
      | 'CLM_ING_INV_LTR_LD'
      | 'LETTER_LE'
      | 'INSURANCELETTER_LI'
      | 'CREW_LETTER_LM'
      | 'CLAIM_PAYMLETT_LP'
      | 'LEGAL_RECOVERY_LR'
      | 'CERTIFICATE_LS'
      | 'LETTER_EXPIRE_LX'
      | 'LETTER_MORTGAAG_LY'
      | 'LETTER_SECURITY_LZ'
      | 'COASTAL_OFFER_MC'
      | 'MAIL_CONFIRMAT_ML'
      | 'MARINE_OFFER_MM'
      | 'MAIL_EML_FILE_MP'
      | 'NEW_PERSON_NP'
      | 'OCR_IMPORT_OC'
      | 'DEBIT_ADVICE_OG'
      | 'PERIODICAL_PAY_P_'
      | 'PAYMENT_ADVICE_PA'
      | 'PRES_TO_CLIENT_PC'
      | 'PERSON_DOCUMENT_PE'
      | 'PL_REMINDER_PL'
      | 'PAYMENT_PM'
      | 'PERSON_OFFER_PO'
      | 'PRINT_DRAFT_PP'
      | 'STATEMENT_PS'
      | 'TECHN_STMT_PT'
      | 'PREM_WAIVER_PW'
      | 'REQ_FOR_QUOTE_QU'
      | '_1REMINDER_R1'
      | '_2REMINDER_R2'
      | '_3REMINDER_R3'
      | '_4REMINDER_R4'
      | '_7REMINDER_R7'
      | '_8REMINDER_R8'
      | '_9REMINDER_R9'
      | 'CREDIT_NOTE_RC'
      | 'REMARK_RE'
      | 'MAX_NOTE_RM'
      | 'REMINDER_NOTE_RN'
      | 'ONLINE_NOTE_RO'
      | 'STATMENT_PREMIU_RP'
      | 'STATMENT_CLAIM_RQ'
      | 'PERSAC_LETTER_RS'
      | 'EXPIRE_REMINDER_RX'
      | 'SLIP_SL'
      | 'SYSTEM_MESSAGE_SM'
      | 'SLOW_PAYER_SP'
      | 'SYSTEM_SY'
      | 'TRIP_IMPORT_TI'
      | 'TAX_TFA_TT'
      | 'TAX_DOC_TX'
      | 'EXCEL_EXPORT_XL'
      | 'PLACEHOLDER_ZZ'
    >,
    orderBy?:
      | 'ID'
      | 'NAME'
      | 'DISPLAY_NAME'
      | 'DESCRIPTION'
      | 'REFERENCE'
      | 'MIME_TYPE'
      | 'MIME_SUBTYPE'
      | 'STATUS'
      | 'APPROVAL_STATUS'
      | 'FORM_TYPE'
      | 'ENTITY_TYPE'
      | 'CREATED'
      | 'CREATED_BY'
      | 'YEAR'
      | 'DOCUMENT_NUMBER'
      | 'PERSON_NAME'
      | 'PERSON_ID',
    orderByDirection?: 'ASC' | 'DESC',
    personId?: string,
    fromYear?: number,
    toYear?: number,
    createdBy?: string,
    reference?: string,
    fromDocumentNumber?: number,
    toDocumentNumber?: number,
    electronic?: boolean,
    attachmentType?: 'AGREEMENT',
    toBeSignedBy?: string,
    documentSignatureStatuses?: Array<
      'SIG_NOT_REQ_N' | 'REJECTED_R' | 'SIGNED_S' | 'TO_BE_SIGNED_T'
    >,
    folderId?: number,
    name?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<SearchResultDocumentArchive>>;
  public search3(
    firstResult?: number,
    maxResults?: number,
    entityType?:
      | 'CLAIM'
      | 'INVOICE'
      | 'COVER_NOTE'
      | 'AGREEMENT'
      | 'POLICY'
      | 'PREMIUM',
    entityKey?: string,
    entityKeys?: Array<string>,
    includeCancelled?: boolean,
    includeAttachments?: boolean,
    excludeNotViewable?: boolean,
    excludeCanNotView?: boolean,
    statuses?: Array<'ACTIVE_A' | 'CANCELLED_C' | 'REPLACED_R' | 'WORK_W'>,
    approvalStatuses?: Array<
      'APPROVED_A' | 'DENIED_D' | 'NEVER_N' | 'TO_BE_APPROVED_T'
    >,
    fromDate?: string,
    toDate?: string,
    formTypes?: Array<
      | 'CTRL_PAYMENTS___'
      | 'ACCOUNT_DOC_AD'
      | 'ACCOUNT_EXPORT_AE'
      | 'AVTALEGIRO_AG'
      | 'ACCOUNT_LIST_AL'
      | 'ATTACHMENT_AT'
      | 'AD_BORD_BA'
      | 'CLOSE_BORD_BC'
      | 'CORR_BORD_BK'
      | 'CLAIM_BORD_BL'
      | 'CLAIM_ADVICE_BM'
      | 'PROV_BORD_BP'
      | 'CANCEL_BS'
      | 'ADD_BORD_BV'
      | 'CANCEL_CA'
      | 'COVER_CREW_NOTE_CC'
      | 'CREW_DISCLETTE_CD'
      | 'COVNOTE_EXTRACT_CE'
      | 'CREWLIST_GEN_CG'
      | 'CLAIM_INVOICE_CI'
      | 'CLMCTRL_CK'
      | 'COVER_NOTE_CN'
      | 'CHANGE_OBJ_CO'
      | 'CREW_SETTLEMENT_CS'
      | 'DEBIT_AGENTNOTE_DA'
      | 'COV_DECLARATION_DE'
      | 'DEDUCT_INVOICE_DI'
      | 'INVOICE_DN'
      | 'IMP_ELBORD_EB'
      | 'E_INVOICE_EI'
      | 'ELREMIT_EL'
      | 'FREIGHT_O_CERTI_FC'
      | 'SINGLE_GIRO_GI'
      | 'GIRO_NOTE_GN'
      | 'INTRST_CALC_IC'
      | 'CREDIT_ADVICE_IG'
      | 'INFO_CLAIM_IL'
      | 'INS_INFO_IN'
      | 'INFO_PREMIUM_IP'
      | 'AGREEM_LETTER_LA'
      | 'BENEFIC_LETTER_LB'
      | 'CLAIM_LETTER_LC'
      | 'CLM_ING_INV_LTR_LD'
      | 'LETTER_LE'
      | 'INSURANCELETTER_LI'
      | 'CREW_LETTER_LM'
      | 'CLAIM_PAYMLETT_LP'
      | 'LEGAL_RECOVERY_LR'
      | 'CERTIFICATE_LS'
      | 'LETTER_EXPIRE_LX'
      | 'LETTER_MORTGAAG_LY'
      | 'LETTER_SECURITY_LZ'
      | 'COASTAL_OFFER_MC'
      | 'MAIL_CONFIRMAT_ML'
      | 'MARINE_OFFER_MM'
      | 'MAIL_EML_FILE_MP'
      | 'NEW_PERSON_NP'
      | 'OCR_IMPORT_OC'
      | 'DEBIT_ADVICE_OG'
      | 'PERIODICAL_PAY_P_'
      | 'PAYMENT_ADVICE_PA'
      | 'PRES_TO_CLIENT_PC'
      | 'PERSON_DOCUMENT_PE'
      | 'PL_REMINDER_PL'
      | 'PAYMENT_PM'
      | 'PERSON_OFFER_PO'
      | 'PRINT_DRAFT_PP'
      | 'STATEMENT_PS'
      | 'TECHN_STMT_PT'
      | 'PREM_WAIVER_PW'
      | 'REQ_FOR_QUOTE_QU'
      | '_1REMINDER_R1'
      | '_2REMINDER_R2'
      | '_3REMINDER_R3'
      | '_4REMINDER_R4'
      | '_7REMINDER_R7'
      | '_8REMINDER_R8'
      | '_9REMINDER_R9'
      | 'CREDIT_NOTE_RC'
      | 'REMARK_RE'
      | 'MAX_NOTE_RM'
      | 'REMINDER_NOTE_RN'
      | 'ONLINE_NOTE_RO'
      | 'STATMENT_PREMIU_RP'
      | 'STATMENT_CLAIM_RQ'
      | 'PERSAC_LETTER_RS'
      | 'EXPIRE_REMINDER_RX'
      | 'SLIP_SL'
      | 'SYSTEM_MESSAGE_SM'
      | 'SLOW_PAYER_SP'
      | 'SYSTEM_SY'
      | 'TRIP_IMPORT_TI'
      | 'TAX_TFA_TT'
      | 'TAX_DOC_TX'
      | 'EXCEL_EXPORT_XL'
      | 'PLACEHOLDER_ZZ'
    >,
    excludeFormTypes?: Array<
      | 'CTRL_PAYMENTS___'
      | 'ACCOUNT_DOC_AD'
      | 'ACCOUNT_EXPORT_AE'
      | 'AVTALEGIRO_AG'
      | 'ACCOUNT_LIST_AL'
      | 'ATTACHMENT_AT'
      | 'AD_BORD_BA'
      | 'CLOSE_BORD_BC'
      | 'CORR_BORD_BK'
      | 'CLAIM_BORD_BL'
      | 'CLAIM_ADVICE_BM'
      | 'PROV_BORD_BP'
      | 'CANCEL_BS'
      | 'ADD_BORD_BV'
      | 'CANCEL_CA'
      | 'COVER_CREW_NOTE_CC'
      | 'CREW_DISCLETTE_CD'
      | 'COVNOTE_EXTRACT_CE'
      | 'CREWLIST_GEN_CG'
      | 'CLAIM_INVOICE_CI'
      | 'CLMCTRL_CK'
      | 'COVER_NOTE_CN'
      | 'CHANGE_OBJ_CO'
      | 'CREW_SETTLEMENT_CS'
      | 'DEBIT_AGENTNOTE_DA'
      | 'COV_DECLARATION_DE'
      | 'DEDUCT_INVOICE_DI'
      | 'INVOICE_DN'
      | 'IMP_ELBORD_EB'
      | 'E_INVOICE_EI'
      | 'ELREMIT_EL'
      | 'FREIGHT_O_CERTI_FC'
      | 'SINGLE_GIRO_GI'
      | 'GIRO_NOTE_GN'
      | 'INTRST_CALC_IC'
      | 'CREDIT_ADVICE_IG'
      | 'INFO_CLAIM_IL'
      | 'INS_INFO_IN'
      | 'INFO_PREMIUM_IP'
      | 'AGREEM_LETTER_LA'
      | 'BENEFIC_LETTER_LB'
      | 'CLAIM_LETTER_LC'
      | 'CLM_ING_INV_LTR_LD'
      | 'LETTER_LE'
      | 'INSURANCELETTER_LI'
      | 'CREW_LETTER_LM'
      | 'CLAIM_PAYMLETT_LP'
      | 'LEGAL_RECOVERY_LR'
      | 'CERTIFICATE_LS'
      | 'LETTER_EXPIRE_LX'
      | 'LETTER_MORTGAAG_LY'
      | 'LETTER_SECURITY_LZ'
      | 'COASTAL_OFFER_MC'
      | 'MAIL_CONFIRMAT_ML'
      | 'MARINE_OFFER_MM'
      | 'MAIL_EML_FILE_MP'
      | 'NEW_PERSON_NP'
      | 'OCR_IMPORT_OC'
      | 'DEBIT_ADVICE_OG'
      | 'PERIODICAL_PAY_P_'
      | 'PAYMENT_ADVICE_PA'
      | 'PRES_TO_CLIENT_PC'
      | 'PERSON_DOCUMENT_PE'
      | 'PL_REMINDER_PL'
      | 'PAYMENT_PM'
      | 'PERSON_OFFER_PO'
      | 'PRINT_DRAFT_PP'
      | 'STATEMENT_PS'
      | 'TECHN_STMT_PT'
      | 'PREM_WAIVER_PW'
      | 'REQ_FOR_QUOTE_QU'
      | '_1REMINDER_R1'
      | '_2REMINDER_R2'
      | '_3REMINDER_R3'
      | '_4REMINDER_R4'
      | '_7REMINDER_R7'
      | '_8REMINDER_R8'
      | '_9REMINDER_R9'
      | 'CREDIT_NOTE_RC'
      | 'REMARK_RE'
      | 'MAX_NOTE_RM'
      | 'REMINDER_NOTE_RN'
      | 'ONLINE_NOTE_RO'
      | 'STATMENT_PREMIU_RP'
      | 'STATMENT_CLAIM_RQ'
      | 'PERSAC_LETTER_RS'
      | 'EXPIRE_REMINDER_RX'
      | 'SLIP_SL'
      | 'SYSTEM_MESSAGE_SM'
      | 'SLOW_PAYER_SP'
      | 'SYSTEM_SY'
      | 'TRIP_IMPORT_TI'
      | 'TAX_TFA_TT'
      | 'TAX_DOC_TX'
      | 'EXCEL_EXPORT_XL'
      | 'PLACEHOLDER_ZZ'
    >,
    orderBy?:
      | 'ID'
      | 'NAME'
      | 'DISPLAY_NAME'
      | 'DESCRIPTION'
      | 'REFERENCE'
      | 'MIME_TYPE'
      | 'MIME_SUBTYPE'
      | 'STATUS'
      | 'APPROVAL_STATUS'
      | 'FORM_TYPE'
      | 'ENTITY_TYPE'
      | 'CREATED'
      | 'CREATED_BY'
      | 'YEAR'
      | 'DOCUMENT_NUMBER'
      | 'PERSON_NAME'
      | 'PERSON_ID',
    orderByDirection?: 'ASC' | 'DESC',
    personId?: string,
    fromYear?: number,
    toYear?: number,
    createdBy?: string,
    reference?: string,
    fromDocumentNumber?: number,
    toDocumentNumber?: number,
    electronic?: boolean,
    attachmentType?: 'AGREEMENT',
    toBeSignedBy?: string,
    documentSignatureStatuses?: Array<
      'SIG_NOT_REQ_N' | 'REJECTED_R' | 'SIGNED_S' | 'TO_BE_SIGNED_T'
    >,
    folderId?: number,
    name?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (firstResult !== undefined && firstResult !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>firstResult,
        'firstResult'
      );
    }
    if (maxResults !== undefined && maxResults !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>maxResults,
        'maxResults'
      );
    }
    if (entityType !== undefined && entityType !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>entityType,
        'entityType'
      );
    }
    if (entityKey !== undefined && entityKey !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>entityKey,
        'entityKey'
      );
    }
    if (entityKeys) {
      entityKeys.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'entityKeys'
        );
      });
    }
    if (includeCancelled !== undefined && includeCancelled !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>includeCancelled,
        'includeCancelled'
      );
    }
    if (includeAttachments !== undefined && includeAttachments !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>includeAttachments,
        'includeAttachments'
      );
    }
    if (excludeNotViewable !== undefined && excludeNotViewable !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>excludeNotViewable,
        'excludeNotViewable'
      );
    }
    if (excludeCanNotView !== undefined && excludeCanNotView !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>excludeCanNotView,
        'excludeCanNotView'
      );
    }
    if (statuses) {
      statuses.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'statuses'
        );
      });
    }
    if (approvalStatuses) {
      approvalStatuses.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'approvalStatuses'
        );
      });
    }
    if (fromDate !== undefined && fromDate !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>fromDate,
        'fromDate'
      );
    }
    if (toDate !== undefined && toDate !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>toDate,
        'toDate'
      );
    }
    if (formTypes) {
      formTypes.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'formTypes'
        );
      });
    }
    if (excludeFormTypes) {
      excludeFormTypes.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'excludeFormTypes'
        );
      });
    }
    if (orderBy !== undefined && orderBy !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>orderBy,
        'orderBy'
      );
    }
    if (orderByDirection !== undefined && orderByDirection !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>orderByDirection,
        'orderByDirection'
      );
    }
    if (personId !== undefined && personId !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>personId,
        'personId'
      );
    }
    if (fromYear !== undefined && fromYear !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>fromYear,
        'fromYear'
      );
    }
    if (toYear !== undefined && toYear !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>toYear,
        'toYear'
      );
    }
    if (createdBy !== undefined && createdBy !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>createdBy,
        'createdBy'
      );
    }
    if (reference !== undefined && reference !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>reference,
        'reference'
      );
    }
    if (fromDocumentNumber !== undefined && fromDocumentNumber !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>fromDocumentNumber,
        'fromDocumentNumber'
      );
    }
    if (toDocumentNumber !== undefined && toDocumentNumber !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>toDocumentNumber,
        'toDocumentNumber'
      );
    }
    if (electronic !== undefined && electronic !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>electronic,
        'electronic'
      );
    }
    if (attachmentType !== undefined && attachmentType !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>attachmentType,
        'attachmentType'
      );
    }
    if (toBeSignedBy !== undefined && toBeSignedBy !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>toBeSignedBy,
        'toBeSignedBy'
      );
    }
    if (documentSignatureStatuses) {
      documentSignatureStatuses.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'documentSignatureStatuses'
        );
      });
    }
    if (folderId !== undefined && folderId !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>folderId,
        'folderId'
      );
    }
    if (name !== undefined && name !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>name,
        'name'
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.get<SearchResultDocumentArchive>(
      `${this.configuration.basePath}/documentarchive`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * @param approvalStatus
   * @param body
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public setApprovalStatus1(
    approvalStatus: 'APPROVED_A' | 'DENIED_D' | 'NEVER_N' | 'TO_BE_APPROVED_T',
    body?: Array<number>,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext }
  ): Observable<any>;
  public setApprovalStatus1(
    approvalStatus: 'APPROVED_A' | 'DENIED_D' | 'NEVER_N' | 'TO_BE_APPROVED_T',
    body?: Array<number>,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext }
  ): Observable<HttpResponse<any>>;
  public setApprovalStatus1(
    approvalStatus: 'APPROVED_A' | 'DENIED_D' | 'NEVER_N' | 'TO_BE_APPROVED_T',
    body?: Array<number>,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext }
  ): Observable<HttpEvent<any>>;
  public setApprovalStatus1(
    approvalStatus: 'APPROVED_A' | 'DENIED_D' | 'NEVER_N' | 'TO_BE_APPROVED_T',
    body?: Array<number>,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext }
  ): Observable<any> {
    if (approvalStatus === null || approvalStatus === undefined) {
      throw new Error(
        'Required parameter approvalStatus was null or undefined when calling setApprovalStatus1.'
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = [];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Content-Type',
        httpContentTypeSelected
      );
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.put<any>(
      `${
        this.configuration.basePath
      }/documentarchive/approvalstatus/${encodeURIComponent(
        String(approvalStatus)
      )}`,
      body,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * @param status
   * @param body
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public setStatus2(
    status: 'ACTIVE_A' | 'CANCELLED_C' | 'REPLACED_R' | 'WORK_W',
    body?: Array<number>,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext }
  ): Observable<any>;
  public setStatus2(
    status: 'ACTIVE_A' | 'CANCELLED_C' | 'REPLACED_R' | 'WORK_W',
    body?: Array<number>,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext }
  ): Observable<HttpResponse<any>>;
  public setStatus2(
    status: 'ACTIVE_A' | 'CANCELLED_C' | 'REPLACED_R' | 'WORK_W',
    body?: Array<number>,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext }
  ): Observable<HttpEvent<any>>;
  public setStatus2(
    status: 'ACTIVE_A' | 'CANCELLED_C' | 'REPLACED_R' | 'WORK_W',
    body?: Array<number>,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext }
  ): Observable<any> {
    if (status === null || status === undefined) {
      throw new Error(
        'Required parameter status was null or undefined when calling setStatus2.'
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = [];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Content-Type',
        httpContentTypeSelected
      );
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.put<any>(
      `${
        this.configuration.basePath
      }/documentarchive/status/${encodeURIComponent(String(status))}`,
      body,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * Electronically sign the specified document
   * @param id Document id
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public sign1(
    id: number,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext }
  ): Observable<any>;
  public sign1(
    id: number,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext }
  ): Observable<HttpResponse<any>>;
  public sign1(
    id: number,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext }
  ): Observable<HttpEvent<any>>;
  public sign1(
    id: number,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext }
  ): Observable<any> {
    if (id === null || id === undefined) {
      throw new Error(
        'Required parameter id was null or undefined when calling sign1.'
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = [];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.post<any>(
      `${this.configuration.basePath}/documentarchive/${encodeURIComponent(
        String(id)
      )}/sign`,
      null,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * Update folder name and folder color
   * @param id Folder id
   * @param folderName Folder name
   * @param colorCode Folder  color
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public update3(
    id: number,
    folderName: string,
    colorCode: 'BLUE_B' | 'GRAY_1' | 'GREEN_G' | 'RED_R' | 'YELLOW_Y',
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<Folder>;
  public update3(
    id: number,
    folderName: string,
    colorCode: 'BLUE_B' | 'GRAY_1' | 'GREEN_G' | 'RED_R' | 'YELLOW_Y',
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<Folder>>;
  public update3(
    id: number,
    folderName: string,
    colorCode: 'BLUE_B' | 'GRAY_1' | 'GREEN_G' | 'RED_R' | 'YELLOW_Y',
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<Folder>>;
  public update3(
    id: number,
    folderName: string,
    colorCode: 'BLUE_B' | 'GRAY_1' | 'GREEN_G' | 'RED_R' | 'YELLOW_Y',
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    if (id === null || id === undefined) {
      throw new Error(
        'Required parameter id was null or undefined when calling update3.'
      );
    }
    if (folderName === null || folderName === undefined) {
      throw new Error(
        'Required parameter folderName was null or undefined when calling update3.'
      );
    }
    if (colorCode === null || colorCode === undefined) {
      throw new Error(
        'Required parameter colorCode was null or undefined when calling update3.'
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (folderName !== undefined && folderName !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>folderName,
        'folderName'
      );
    }
    if (colorCode !== undefined && colorCode !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>colorCode,
        'colorCode'
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.put<Folder>(
      `${
        this.configuration.basePath
      }/documentarchive/folders/${encodeURIComponent(String(id))}/update`,
      null,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * @param body
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public update4(
    body?: DocumentArchive,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<DocumentArchive>;
  public update4(
    body?: DocumentArchive,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<DocumentArchive>>;
  public update4(
    body?: DocumentArchive,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<DocumentArchive>>;
  public update4(
    body?: DocumentArchive,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Content-Type',
        httpContentTypeSelected
      );
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.put<DocumentArchive>(
      `${this.configuration.basePath}/documentarchive`,
      body,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * Update document binary data. When createNew is true, the service will cancel the document and create a new one, otherwise the service will update the binary data. Default: false.
   * @param id
   * @param fileName
   * @param createNew
   * @param data
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public updateData1(
    id?: number,
    fileName?: string,
    createNew?: any,
    data?: Blob,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<DocumentArchive>;
  public updateData1(
    id?: number,
    fileName?: string,
    createNew?: any,
    data?: Blob,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<DocumentArchive>>;
  public updateData1(
    id?: number,
    fileName?: string,
    createNew?: any,
    data?: Blob,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<DocumentArchive>>;
  public updateData1(
    id?: number,
    fileName?: string,
    createNew?: any,
    data?: Blob,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = ['multipart/form-data'];

    const canConsumeForm = this.canConsumeForm(consumes);

    let localVarFormParams: { append(param: string, value: any): any };
    let localVarUseForm = false;
    let localVarConvertFormParamsToString = false;
    if (localVarUseForm) {
      localVarFormParams = new FormData();
    } else {
      localVarFormParams = new HttpParams({ encoder: this.encoder });
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.put<DocumentArchive>(
      `${this.configuration.basePath}/documentarchive/data`,
      localVarConvertFormParamsToString
        ? localVarFormParams.toString()
        : localVarFormParams,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }
}

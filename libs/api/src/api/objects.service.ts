/**
 * PARIS API
 * The PARIS API is based on a REST achitecture, and is using JSON as data format.<br/>PARIS API is Stateless, the server does not store any state about the client session on the server side. Statelessness ensures that each service consumer request can be treated independently by the service.<br/>Authentication against the API is done using a combination of Basic Authentication and Token based authentication or API-Keys.<br/><br/>Â©2021 NORIA AS. All Rights Reserved. PARIS is a trademark of <a href=\"http://noria.no/\" target=\"_blank\">NORIA AS</a>.
 *
 * The version of the OpenAPI document: 4.7-202112021325
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional } from '@angular/core';
import {
  HttpClient,
  HttpHeaders,
  HttpParams,
  HttpResponse,
  HttpEvent,
  HttpParameterCodec,
  HttpContext,
} from '@angular/common/http';
import { CustomHttpParameterCodec } from '../encoder';
import { Observable } from 'rxjs';

import { ImoNumberValidation } from '../model/models';
import { InsuredObject } from '../model/models';
import { InsuredObjectDetails } from '../model/models';
import { InsuredObjectFleet } from '../model/models';
import { InsuredObjectInitParams } from '../model/models';
import { InsuredObjectInitVersionParams } from '../model/models';
import { InsuredObjectRole } from '../model/models';
import { InsuredObjectStatistic } from '../model/models';
import { Mortgagee } from '../model/models';
import { SearchResultInsuredObject } from '../model/models';
import { SearchResultInsuredObjectFleet } from '../model/models';
import { SearchResultSimpleInsuredObject } from '../model/models';

import { BASE_PATH, COLLECTION_FORMATS } from '../variables';
import { Configuration } from '../configuration';

@Injectable({
  providedIn: 'root',
})
export class ObjectsService {
  protected basePath = 'http://localhost/noria-dev/rest';
  public defaultHeaders = new HttpHeaders();
  public configuration = new Configuration();
  public encoder: HttpParameterCodec;

  constructor(
    protected httpClient: HttpClient,
    @Optional() @Inject(BASE_PATH) basePath: string,
    @Optional() configuration: Configuration
  ) {
    if (configuration) {
      this.configuration = configuration;
    }
    if (typeof this.configuration.basePath !== 'string') {
      if (typeof basePath !== 'string') {
        basePath = this.basePath;
      }
      this.configuration.basePath = basePath;
    }
    this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
  }

  private addToHttpParams(
    httpParams: HttpParams,
    value: any,
    key?: string
  ): HttpParams {
    if (typeof value === 'object' && value instanceof Date === false) {
      httpParams = this.addToHttpParamsRecursive(httpParams, value);
    } else {
      httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
    }
    return httpParams;
  }

  private addToHttpParamsRecursive(
    httpParams: HttpParams,
    value?: any,
    key?: string
  ): HttpParams {
    if (value == null) {
      return httpParams;
    }

    if (typeof value === 'object') {
      if (Array.isArray(value)) {
        (value as any[]).forEach(
          (elem) =>
            (httpParams = this.addToHttpParamsRecursive(httpParams, elem, key))
        );
      } else if (value instanceof Date) {
        if (key != null) {
          httpParams = httpParams.append(
            key,
            (value as Date).toISOString().substr(0, 10)
          );
        } else {
          throw Error('key may not be null if value is Date');
        }
      } else {
        Object.keys(value).forEach(
          (k) =>
            (httpParams = this.addToHttpParamsRecursive(
              httpParams,
              value[k],
              key != null ? `${key}.${k}` : k
            ))
        );
      }
    } else if (key != null) {
      httpParams = httpParams.append(key, value);
    } else {
      throw Error('key may not be null if value is not object or array');
    }
    return httpParams;
  }

  /**
   * @param versionId
   * @param body
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public changeRoles2(
    versionId: string,
    body?: Array<InsuredObjectRole>,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<Array<InsuredObjectRole>>;
  public changeRoles2(
    versionId: string,
    body?: Array<InsuredObjectRole>,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<Array<InsuredObjectRole>>>;
  public changeRoles2(
    versionId: string,
    body?: Array<InsuredObjectRole>,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<Array<InsuredObjectRole>>>;
  public changeRoles2(
    versionId: string,
    body?: Array<InsuredObjectRole>,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    if (versionId === null || versionId === undefined) {
      throw new Error(
        'Required parameter versionId was null or undefined when calling changeRoles2.'
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Content-Type',
        httpContentTypeSelected
      );
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.post<Array<InsuredObjectRole>>(
      `${this.configuration.basePath}/objects/versions/${encodeURIComponent(
        String(versionId)
      )}/roles`,
      body,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * @param body
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public create8(
    body?: InsuredObject,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<InsuredObject>;
  public create8(
    body?: InsuredObject,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<InsuredObject>>;
  public create8(
    body?: InsuredObject,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<InsuredObject>>;
  public create8(
    body?: InsuredObject,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Content-Type',
        httpContentTypeSelected
      );
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.post<InsuredObject>(
      `${this.configuration.basePath}/objects`,
      body,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * @param versionId
   * @param body
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public createInsuredObjectDetails1(
    versionId: string,
    body?: InsuredObjectDetails,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<InsuredObjectDetails>;
  public createInsuredObjectDetails1(
    versionId: string,
    body?: InsuredObjectDetails,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<InsuredObjectDetails>>;
  public createInsuredObjectDetails1(
    versionId: string,
    body?: InsuredObjectDetails,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<InsuredObjectDetails>>;
  public createInsuredObjectDetails1(
    versionId: string,
    body?: InsuredObjectDetails,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    if (versionId === null || versionId === undefined) {
      throw new Error(
        'Required parameter versionId was null or undefined when calling createInsuredObjectDetails1.'
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Content-Type',
        httpContentTypeSelected
      );
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.post<InsuredObjectDetails>(
      `${this.configuration.basePath}/objects/versions/${encodeURIComponent(
        String(versionId)
      )}/details`,
      body,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * @param versionId
   * @param body
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public createMortgagee1(
    versionId: string,
    body?: Mortgagee,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<Mortgagee>;
  public createMortgagee1(
    versionId: string,
    body?: Mortgagee,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<Mortgagee>>;
  public createMortgagee1(
    versionId: string,
    body?: Mortgagee,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<Mortgagee>>;
  public createMortgagee1(
    versionId: string,
    body?: Mortgagee,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    if (versionId === null || versionId === undefined) {
      throw new Error(
        'Required parameter versionId was null or undefined when calling createMortgagee1.'
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Content-Type',
        httpContentTypeSelected
      );
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.post<Mortgagee>(
      `${this.configuration.basePath}/objects/versions/${encodeURIComponent(
        String(versionId)
      )}/mortgagees`,
      body,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * @param body
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public createVersion2(
    body?: InsuredObject,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<InsuredObject>;
  public createVersion2(
    body?: InsuredObject,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<InsuredObject>>;
  public createVersion2(
    body?: InsuredObject,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<InsuredObject>>;
  public createVersion2(
    body?: InsuredObject,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Content-Type',
        httpContentTypeSelected
      );
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.post<InsuredObject>(
      `${this.configuration.basePath}/objects/versions`,
      body,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * @param insuredObjectDetailsId
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public deleteInsuredObjectDetails1(
    insuredObjectDetailsId: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext }
  ): Observable<any>;
  public deleteInsuredObjectDetails1(
    insuredObjectDetailsId: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext }
  ): Observable<HttpResponse<any>>;
  public deleteInsuredObjectDetails1(
    insuredObjectDetailsId: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext }
  ): Observable<HttpEvent<any>>;
  public deleteInsuredObjectDetails1(
    insuredObjectDetailsId: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext }
  ): Observable<any> {
    if (
      insuredObjectDetailsId === null ||
      insuredObjectDetailsId === undefined
    ) {
      throw new Error(
        'Required parameter insuredObjectDetailsId was null or undefined when calling deleteInsuredObjectDetails1.'
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = [];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.delete<any>(
      `${
        this.configuration.basePath
      }/objects/versions/details/${encodeURIComponent(
        String(insuredObjectDetailsId)
      )}`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * @param mortgageeId
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public deleteMortgagee1(
    mortgageeId: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext }
  ): Observable<any>;
  public deleteMortgagee1(
    mortgageeId: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext }
  ): Observable<HttpResponse<any>>;
  public deleteMortgagee1(
    mortgageeId: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext }
  ): Observable<HttpEvent<any>>;
  public deleteMortgagee1(
    mortgageeId: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: undefined; context?: HttpContext }
  ): Observable<any> {
    if (mortgageeId === null || mortgageeId === undefined) {
      throw new Error(
        'Required parameter mortgageeId was null or undefined when calling deleteMortgagee1.'
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = [];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.delete<any>(
      `${
        this.configuration.basePath
      }/objects/versions/mortgagees/${encodeURIComponent(String(mortgageeId))}`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * @param id
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public get11(
    id: number,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<InsuredObject>;
  public get11(
    id: number,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<InsuredObject>>;
  public get11(
    id: number,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<InsuredObject>>;
  public get11(
    id: number,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    if (id === null || id === undefined) {
      throw new Error(
        'Required parameter id was null or undefined when calling get11.'
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.get<InsuredObject>(
      `${this.configuration.basePath}/objects/${encodeURIComponent(
        String(id)
      )}`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * @param imoNumber
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getFromFairPlay1(
    imoNumber: number,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<InsuredObject>;
  public getFromFairPlay1(
    imoNumber: number,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<InsuredObject>>;
  public getFromFairPlay1(
    imoNumber: number,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<InsuredObject>>;
  public getFromFairPlay1(
    imoNumber: number,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    if (imoNumber === null || imoNumber === undefined) {
      throw new Error(
        'Required parameter imoNumber was null or undefined when calling getFromFairPlay1.'
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.get<InsuredObject>(
      `${this.configuration.basePath}/objects/fairplay/${encodeURIComponent(
        String(imoNumber)
      )}`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * @param insuredObjectDetailsId
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getInsuredObjectDetails1(
    insuredObjectDetailsId: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<InsuredObjectDetails>;
  public getInsuredObjectDetails1(
    insuredObjectDetailsId: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<InsuredObjectDetails>>;
  public getInsuredObjectDetails1(
    insuredObjectDetailsId: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<InsuredObjectDetails>>;
  public getInsuredObjectDetails1(
    insuredObjectDetailsId: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    if (
      insuredObjectDetailsId === null ||
      insuredObjectDetailsId === undefined
    ) {
      throw new Error(
        'Required parameter insuredObjectDetailsId was null or undefined when calling getInsuredObjectDetails1.'
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.get<InsuredObjectDetails>(
      `${
        this.configuration.basePath
      }/objects/versions/details/${encodeURIComponent(
        String(insuredObjectDetailsId)
      )}`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * @param versionId
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getInsuredObjectDetailsList1(
    versionId: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<Array<InsuredObjectDetails>>;
  public getInsuredObjectDetailsList1(
    versionId: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<Array<InsuredObjectDetails>>>;
  public getInsuredObjectDetailsList1(
    versionId: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<Array<InsuredObjectDetails>>>;
  public getInsuredObjectDetailsList1(
    versionId: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    if (versionId === null || versionId === undefined) {
      throw new Error(
        'Required parameter versionId was null or undefined when calling getInsuredObjectDetailsList1.'
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.get<Array<InsuredObjectDetails>>(
      `${this.configuration.basePath}/objects/versions/${encodeURIComponent(
        String(versionId)
      )}/details`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * @param insuredObjectFleetId
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getInsuredObjectFleet1(
    insuredObjectFleetId: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<InsuredObjectFleet>;
  public getInsuredObjectFleet1(
    insuredObjectFleetId: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<InsuredObjectFleet>>;
  public getInsuredObjectFleet1(
    insuredObjectFleetId: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<InsuredObjectFleet>>;
  public getInsuredObjectFleet1(
    insuredObjectFleetId: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    if (insuredObjectFleetId === null || insuredObjectFleetId === undefined) {
      throw new Error(
        'Required parameter insuredObjectFleetId was null or undefined when calling getInsuredObjectFleet1.'
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.get<InsuredObjectFleet>(
      `${this.configuration.basePath}/objects/fleet/${encodeURIComponent(
        String(insuredObjectFleetId)
      )}`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * @param firstResult
   * @param maxResults
   * @param objectNumber
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getInsuredObjectFleetList1(
    firstResult?: number,
    maxResults?: number,
    objectNumber?: number,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<SearchResultInsuredObjectFleet>;
  public getInsuredObjectFleetList1(
    firstResult?: number,
    maxResults?: number,
    objectNumber?: number,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<SearchResultInsuredObjectFleet>>;
  public getInsuredObjectFleetList1(
    firstResult?: number,
    maxResults?: number,
    objectNumber?: number,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<SearchResultInsuredObjectFleet>>;
  public getInsuredObjectFleetList1(
    firstResult?: number,
    maxResults?: number,
    objectNumber?: number,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (firstResult !== undefined && firstResult !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>firstResult,
        'firstResult'
      );
    }
    if (maxResults !== undefined && maxResults !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>maxResults,
        'maxResults'
      );
    }
    if (objectNumber !== undefined && objectNumber !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>objectNumber,
        'objectNumber'
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.get<SearchResultInsuredObjectFleet>(
      `${this.configuration.basePath}/objects/fleet`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * @param versionId
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getInsuredObjectRoles1(
    versionId: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<Array<InsuredObjectRole>>;
  public getInsuredObjectRoles1(
    versionId: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<Array<InsuredObjectRole>>>;
  public getInsuredObjectRoles1(
    versionId: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<Array<InsuredObjectRole>>>;
  public getInsuredObjectRoles1(
    versionId: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    if (versionId === null || versionId === undefined) {
      throw new Error(
        'Required parameter versionId was null or undefined when calling getInsuredObjectRoles1.'
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.get<Array<InsuredObjectRole>>(
      `${this.configuration.basePath}/objects/versions/${encodeURIComponent(
        String(versionId)
      )}/roles`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * @param personId
   * @param objectNumbers
   * @param fromYear
   * @param toYear
   * @param currency
   * @param insurancesValidPerDate
   * @param interests
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getInsuredObjectStatistics1(
    personId: number,
    objectNumbers?: Array<number>,
    fromYear?: number,
    toYear?: number,
    currency?: string,
    insurancesValidPerDate?: string,
    interests?: Array<string>,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<Array<InsuredObjectStatistic>>;
  public getInsuredObjectStatistics1(
    personId: number,
    objectNumbers?: Array<number>,
    fromYear?: number,
    toYear?: number,
    currency?: string,
    insurancesValidPerDate?: string,
    interests?: Array<string>,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<Array<InsuredObjectStatistic>>>;
  public getInsuredObjectStatistics1(
    personId: number,
    objectNumbers?: Array<number>,
    fromYear?: number,
    toYear?: number,
    currency?: string,
    insurancesValidPerDate?: string,
    interests?: Array<string>,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<Array<InsuredObjectStatistic>>>;
  public getInsuredObjectStatistics1(
    personId: number,
    objectNumbers?: Array<number>,
    fromYear?: number,
    toYear?: number,
    currency?: string,
    insurancesValidPerDate?: string,
    interests?: Array<string>,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    if (personId === null || personId === undefined) {
      throw new Error(
        'Required parameter personId was null or undefined when calling getInsuredObjectStatistics1.'
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (objectNumbers) {
      objectNumbers.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'objectNumbers'
        );
      });
    }
    if (personId !== undefined && personId !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>personId,
        'personId'
      );
    }
    if (fromYear !== undefined && fromYear !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>fromYear,
        'fromYear'
      );
    }
    if (toYear !== undefined && toYear !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>toYear,
        'toYear'
      );
    }
    if (currency !== undefined && currency !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>currency,
        'currency'
      );
    }
    if (
      insurancesValidPerDate !== undefined &&
      insurancesValidPerDate !== null
    ) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>insurancesValidPerDate,
        'insurancesValidPerDate'
      );
    }
    if (interests) {
      interests.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'interests'
        );
      });
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.get<Array<InsuredObjectStatistic>>(
      `${this.configuration.basePath}/objects/statistics`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * @param mortgageeId
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getMortgagee1(
    mortgageeId: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<Mortgagee>;
  public getMortgagee1(
    mortgageeId: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<Mortgagee>>;
  public getMortgagee1(
    mortgageeId: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<Mortgagee>>;
  public getMortgagee1(
    mortgageeId: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    if (mortgageeId === null || mortgageeId === undefined) {
      throw new Error(
        'Required parameter mortgageeId was null or undefined when calling getMortgagee1.'
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.get<Mortgagee>(
      `${
        this.configuration.basePath
      }/objects/versions/mortgagees/${encodeURIComponent(String(mortgageeId))}`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * @param versionId
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getMortgagees1(
    versionId: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<Array<Mortgagee>>;
  public getMortgagees1(
    versionId: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<Array<Mortgagee>>>;
  public getMortgagees1(
    versionId: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<Array<Mortgagee>>>;
  public getMortgagees1(
    versionId: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    if (versionId === null || versionId === undefined) {
      throw new Error(
        'Required parameter versionId was null or undefined when calling getMortgagees1.'
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.get<Array<Mortgagee>>(
      `${this.configuration.basePath}/objects/versions/${encodeURIComponent(
        String(versionId)
      )}/mortgagees`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * @param versionId
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getVersion2(
    versionId: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<InsuredObject>;
  public getVersion2(
    versionId: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<InsuredObject>>;
  public getVersion2(
    versionId: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<InsuredObject>>;
  public getVersion2(
    versionId: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    if (versionId === null || versionId === undefined) {
      throw new Error(
        'Required parameter versionId was null or undefined when calling getVersion2.'
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.get<InsuredObject>(
      `${this.configuration.basePath}/objects/versions/${encodeURIComponent(
        String(versionId)
      )}`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * @param id
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getVersions2(
    id: number,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<Array<string>>;
  public getVersions2(
    id: number,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<Array<string>>>;
  public getVersions2(
    id: number,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<Array<string>>>;
  public getVersions2(
    id: number,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    if (id === null || id === undefined) {
      throw new Error(
        'Required parameter id was null or undefined when calling getVersions2.'
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.get<Array<string>>(
      `${this.configuration.basePath}/objects/${encodeURIComponent(
        String(id)
      )}/versions`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * @param body
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public init5(
    body?: InsuredObjectInitParams,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<InsuredObject>;
  public init5(
    body?: InsuredObjectInitParams,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<InsuredObject>>;
  public init5(
    body?: InsuredObjectInitParams,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<InsuredObject>>;
  public init5(
    body?: InsuredObjectInitParams,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Content-Type',
        httpContentTypeSelected
      );
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.post<InsuredObject>(
      `${this.configuration.basePath}/objects/init`,
      body,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * @param versionId
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public initInsuredObjectDetails1(
    versionId: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<InsuredObjectDetails>;
  public initInsuredObjectDetails1(
    versionId: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<InsuredObjectDetails>>;
  public initInsuredObjectDetails1(
    versionId: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<InsuredObjectDetails>>;
  public initInsuredObjectDetails1(
    versionId: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    if (versionId === null || versionId === undefined) {
      throw new Error(
        'Required parameter versionId was null or undefined when calling initInsuredObjectDetails1.'
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.post<InsuredObjectDetails>(
      `${this.configuration.basePath}/objects/versions/${encodeURIComponent(
        String(versionId)
      )}/details/init`,
      null,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * @param versionId
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public initMortgagee1(
    versionId: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<Mortgagee>;
  public initMortgagee1(
    versionId: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<Mortgagee>>;
  public initMortgagee1(
    versionId: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<Mortgagee>>;
  public initMortgagee1(
    versionId: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    if (versionId === null || versionId === undefined) {
      throw new Error(
        'Required parameter versionId was null or undefined when calling initMortgagee1.'
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.post<Mortgagee>(
      `${this.configuration.basePath}/objects/versions/${encodeURIComponent(
        String(versionId)
      )}/mortgagees/init`,
      null,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * @param versionId
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public initRole2(
    versionId: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<InsuredObjectRole>;
  public initRole2(
    versionId: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<InsuredObjectRole>>;
  public initRole2(
    versionId: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<InsuredObjectRole>>;
  public initRole2(
    versionId: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    if (versionId === null || versionId === undefined) {
      throw new Error(
        'Required parameter versionId was null or undefined when calling initRole2.'
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.post<InsuredObjectRole>(
      `${this.configuration.basePath}/objects/versions/${encodeURIComponent(
        String(versionId)
      )}/roles/init`,
      null,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * @param id
   * @param body
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public initVersion2(
    id: number,
    body?: InsuredObjectInitVersionParams,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<InsuredObject>;
  public initVersion2(
    id: number,
    body?: InsuredObjectInitVersionParams,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<InsuredObject>>;
  public initVersion2(
    id: number,
    body?: InsuredObjectInitVersionParams,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<InsuredObject>>;
  public initVersion2(
    id: number,
    body?: InsuredObjectInitVersionParams,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    if (id === null || id === undefined) {
      throw new Error(
        'Required parameter id was null or undefined when calling initVersion2.'
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Content-Type',
        httpContentTypeSelected
      );
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.post<InsuredObject>(
      `${this.configuration.basePath}/objects/${encodeURIComponent(
        String(id)
      )}/versions/init`,
      body,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * @param firstResult
   * @param maxResults
   * @param objectNumber
   * @param name
   * @param imoNumber
   * @param types
   * @param vesselType
   * @param manager
   * @param owner
   * @param fleetMarine
   * @param identification
   * @param callSignal
   * @param fromInsuranceYear
   * @param toInsuranceYear
   * @param originalInsured
   * @param fleetObjectNumber
   * @param majorCode
   * @param address1
   * @param address2
   * @param city
   * @param flagAreaCode
   * @param fullText
   * @param hasInsurancesOnly
   * @param searchHistorical
   * @param orderBy
   * @param orderByDirection
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public search6(
    firstResult?: number,
    maxResults?: number,
    objectNumber?: number,
    name?: string,
    imoNumber?: number,
    types?: Array<
      | 'VESSEL_1'
      | 'RIG_OBJECT_10'
      | 'FLOATING_INSTAL_12'
      | 'LIABILITY_13'
      | 'AQUAOBJECT_14'
      | 'FISH_15'
      | 'AQUA_CARGO_16'
      | 'COASTAL_2'
      | 'CARGO_OBJECT_3'
      | 'ENERGY_PHYSOBJ_4'
      | 'ENERGY_PACKOBJ_5'
      | 'PROPERTY_6'
      | 'VEHICLE_FLEET_60'
      | 'VEHICLE_61'
      | 'MOTORCYKLE_62'
      | 'MACHINE_63'
      | 'TRAILER_64'
      | 'PERSON_GROUP_65'
      | 'PERSON_66'
      | 'AVIATION_OBJECT_7'
      | 'BUILDING_70'
      | 'CABIN_71'
      | 'ARBEIDSMASKIN_73'
      | 'INVENTORY_74'
      | 'LEISURE_BOAT_75'
      | 'VALUABLES_76'
      | 'ANIMAL_77'
      | 'PLACE_FLEET_78'
      | 'PLACE_8'
      | 'CUMULE_9'
    >,
    vesselType?: string,
    manager?: number,
    owner?: number,
    fleetMarine?: number,
    identification?: string,
    callSignal?: string,
    fromInsuranceYear?: number,
    toInsuranceYear?: number,
    originalInsured?: number,
    fleetObjectNumber?: number,
    majorCode?: number,
    address1?: string,
    address2?: string,
    city?: string,
    flagAreaCode?: string,
    fullText?: string,
    hasInsurancesOnly?: boolean,
    searchHistorical?: boolean,
    orderBy?:
      | 'OBJECT_NUMBER'
      | 'IMO_NUMBER'
      | 'NAME'
      | 'EX_NAME'
      | 'VESSEL_TYPE'
      | 'MANAGER'
      | 'ORIGINAL_BUILT_YEAR',
    orderByDirection?: 'ASC' | 'DESC',
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<SearchResultInsuredObject>;
  public search6(
    firstResult?: number,
    maxResults?: number,
    objectNumber?: number,
    name?: string,
    imoNumber?: number,
    types?: Array<
      | 'VESSEL_1'
      | 'RIG_OBJECT_10'
      | 'FLOATING_INSTAL_12'
      | 'LIABILITY_13'
      | 'AQUAOBJECT_14'
      | 'FISH_15'
      | 'AQUA_CARGO_16'
      | 'COASTAL_2'
      | 'CARGO_OBJECT_3'
      | 'ENERGY_PHYSOBJ_4'
      | 'ENERGY_PACKOBJ_5'
      | 'PROPERTY_6'
      | 'VEHICLE_FLEET_60'
      | 'VEHICLE_61'
      | 'MOTORCYKLE_62'
      | 'MACHINE_63'
      | 'TRAILER_64'
      | 'PERSON_GROUP_65'
      | 'PERSON_66'
      | 'AVIATION_OBJECT_7'
      | 'BUILDING_70'
      | 'CABIN_71'
      | 'ARBEIDSMASKIN_73'
      | 'INVENTORY_74'
      | 'LEISURE_BOAT_75'
      | 'VALUABLES_76'
      | 'ANIMAL_77'
      | 'PLACE_FLEET_78'
      | 'PLACE_8'
      | 'CUMULE_9'
    >,
    vesselType?: string,
    manager?: number,
    owner?: number,
    fleetMarine?: number,
    identification?: string,
    callSignal?: string,
    fromInsuranceYear?: number,
    toInsuranceYear?: number,
    originalInsured?: number,
    fleetObjectNumber?: number,
    majorCode?: number,
    address1?: string,
    address2?: string,
    city?: string,
    flagAreaCode?: string,
    fullText?: string,
    hasInsurancesOnly?: boolean,
    searchHistorical?: boolean,
    orderBy?:
      | 'OBJECT_NUMBER'
      | 'IMO_NUMBER'
      | 'NAME'
      | 'EX_NAME'
      | 'VESSEL_TYPE'
      | 'MANAGER'
      | 'ORIGINAL_BUILT_YEAR',
    orderByDirection?: 'ASC' | 'DESC',
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<SearchResultInsuredObject>>;
  public search6(
    firstResult?: number,
    maxResults?: number,
    objectNumber?: number,
    name?: string,
    imoNumber?: number,
    types?: Array<
      | 'VESSEL_1'
      | 'RIG_OBJECT_10'
      | 'FLOATING_INSTAL_12'
      | 'LIABILITY_13'
      | 'AQUAOBJECT_14'
      | 'FISH_15'
      | 'AQUA_CARGO_16'
      | 'COASTAL_2'
      | 'CARGO_OBJECT_3'
      | 'ENERGY_PHYSOBJ_4'
      | 'ENERGY_PACKOBJ_5'
      | 'PROPERTY_6'
      | 'VEHICLE_FLEET_60'
      | 'VEHICLE_61'
      | 'MOTORCYKLE_62'
      | 'MACHINE_63'
      | 'TRAILER_64'
      | 'PERSON_GROUP_65'
      | 'PERSON_66'
      | 'AVIATION_OBJECT_7'
      | 'BUILDING_70'
      | 'CABIN_71'
      | 'ARBEIDSMASKIN_73'
      | 'INVENTORY_74'
      | 'LEISURE_BOAT_75'
      | 'VALUABLES_76'
      | 'ANIMAL_77'
      | 'PLACE_FLEET_78'
      | 'PLACE_8'
      | 'CUMULE_9'
    >,
    vesselType?: string,
    manager?: number,
    owner?: number,
    fleetMarine?: number,
    identification?: string,
    callSignal?: string,
    fromInsuranceYear?: number,
    toInsuranceYear?: number,
    originalInsured?: number,
    fleetObjectNumber?: number,
    majorCode?: number,
    address1?: string,
    address2?: string,
    city?: string,
    flagAreaCode?: string,
    fullText?: string,
    hasInsurancesOnly?: boolean,
    searchHistorical?: boolean,
    orderBy?:
      | 'OBJECT_NUMBER'
      | 'IMO_NUMBER'
      | 'NAME'
      | 'EX_NAME'
      | 'VESSEL_TYPE'
      | 'MANAGER'
      | 'ORIGINAL_BUILT_YEAR',
    orderByDirection?: 'ASC' | 'DESC',
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<SearchResultInsuredObject>>;
  public search6(
    firstResult?: number,
    maxResults?: number,
    objectNumber?: number,
    name?: string,
    imoNumber?: number,
    types?: Array<
      | 'VESSEL_1'
      | 'RIG_OBJECT_10'
      | 'FLOATING_INSTAL_12'
      | 'LIABILITY_13'
      | 'AQUAOBJECT_14'
      | 'FISH_15'
      | 'AQUA_CARGO_16'
      | 'COASTAL_2'
      | 'CARGO_OBJECT_3'
      | 'ENERGY_PHYSOBJ_4'
      | 'ENERGY_PACKOBJ_5'
      | 'PROPERTY_6'
      | 'VEHICLE_FLEET_60'
      | 'VEHICLE_61'
      | 'MOTORCYKLE_62'
      | 'MACHINE_63'
      | 'TRAILER_64'
      | 'PERSON_GROUP_65'
      | 'PERSON_66'
      | 'AVIATION_OBJECT_7'
      | 'BUILDING_70'
      | 'CABIN_71'
      | 'ARBEIDSMASKIN_73'
      | 'INVENTORY_74'
      | 'LEISURE_BOAT_75'
      | 'VALUABLES_76'
      | 'ANIMAL_77'
      | 'PLACE_FLEET_78'
      | 'PLACE_8'
      | 'CUMULE_9'
    >,
    vesselType?: string,
    manager?: number,
    owner?: number,
    fleetMarine?: number,
    identification?: string,
    callSignal?: string,
    fromInsuranceYear?: number,
    toInsuranceYear?: number,
    originalInsured?: number,
    fleetObjectNumber?: number,
    majorCode?: number,
    address1?: string,
    address2?: string,
    city?: string,
    flagAreaCode?: string,
    fullText?: string,
    hasInsurancesOnly?: boolean,
    searchHistorical?: boolean,
    orderBy?:
      | 'OBJECT_NUMBER'
      | 'IMO_NUMBER'
      | 'NAME'
      | 'EX_NAME'
      | 'VESSEL_TYPE'
      | 'MANAGER'
      | 'ORIGINAL_BUILT_YEAR',
    orderByDirection?: 'ASC' | 'DESC',
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (firstResult !== undefined && firstResult !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>firstResult,
        'firstResult'
      );
    }
    if (maxResults !== undefined && maxResults !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>maxResults,
        'maxResults'
      );
    }
    if (objectNumber !== undefined && objectNumber !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>objectNumber,
        'objectNumber'
      );
    }
    if (name !== undefined && name !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>name,
        'name'
      );
    }
    if (imoNumber !== undefined && imoNumber !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>imoNumber,
        'imoNumber'
      );
    }
    if (types) {
      types.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'types'
        );
      });
    }
    if (vesselType !== undefined && vesselType !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>vesselType,
        'vesselType'
      );
    }
    if (manager !== undefined && manager !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>manager,
        'manager'
      );
    }
    if (owner !== undefined && owner !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>owner,
        'owner'
      );
    }
    if (fleetMarine !== undefined && fleetMarine !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>fleetMarine,
        'fleetMarine'
      );
    }
    if (identification !== undefined && identification !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>identification,
        'identification'
      );
    }
    if (callSignal !== undefined && callSignal !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>callSignal,
        'callSignal'
      );
    }
    if (fromInsuranceYear !== undefined && fromInsuranceYear !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>fromInsuranceYear,
        'fromInsuranceYear'
      );
    }
    if (toInsuranceYear !== undefined && toInsuranceYear !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>toInsuranceYear,
        'toInsuranceYear'
      );
    }
    if (originalInsured !== undefined && originalInsured !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>originalInsured,
        'originalInsured'
      );
    }
    if (fleetObjectNumber !== undefined && fleetObjectNumber !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>fleetObjectNumber,
        'fleetObjectNumber'
      );
    }
    if (majorCode !== undefined && majorCode !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>majorCode,
        'majorCode'
      );
    }
    if (address1 !== undefined && address1 !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>address1,
        'address1'
      );
    }
    if (address2 !== undefined && address2 !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>address2,
        'address2'
      );
    }
    if (city !== undefined && city !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>city,
        'city'
      );
    }
    if (flagAreaCode !== undefined && flagAreaCode !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>flagAreaCode,
        'flagAreaCode'
      );
    }
    if (fullText !== undefined && fullText !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>fullText,
        'fullText'
      );
    }
    if (hasInsurancesOnly !== undefined && hasInsurancesOnly !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>hasInsurancesOnly,
        'hasInsurancesOnly'
      );
    }
    if (searchHistorical !== undefined && searchHistorical !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>searchHistorical,
        'searchHistorical'
      );
    }
    if (orderBy !== undefined && orderBy !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>orderBy,
        'orderBy'
      );
    }
    if (orderByDirection !== undefined && orderByDirection !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>orderByDirection,
        'orderByDirection'
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.get<SearchResultInsuredObject>(
      `${this.configuration.basePath}/objects`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * @param firstResult
   * @param maxResults
   * @param objectNumber
   * @param name
   * @param imoNumber
   * @param types
   * @param vesselType
   * @param manager
   * @param owner
   * @param fleetMarine
   * @param identification
   * @param callSignal
   * @param fromInsuranceYear
   * @param toInsuranceYear
   * @param originalInsured
   * @param fleetObjectNumber
   * @param majorCode
   * @param address1
   * @param address2
   * @param city
   * @param flagAreaCode
   * @param fullText
   * @param hasInsurancesOnly
   * @param searchHistorical
   * @param orderBy
   * @param orderByDirection
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public searchSimple2(
    firstResult?: number,
    maxResults?: number,
    objectNumber?: number,
    name?: string,
    imoNumber?: number,
    types?: Array<
      | 'VESSEL_1'
      | 'RIG_OBJECT_10'
      | 'FLOATING_INSTAL_12'
      | 'LIABILITY_13'
      | 'AQUAOBJECT_14'
      | 'FISH_15'
      | 'AQUA_CARGO_16'
      | 'COASTAL_2'
      | 'CARGO_OBJECT_3'
      | 'ENERGY_PHYSOBJ_4'
      | 'ENERGY_PACKOBJ_5'
      | 'PROPERTY_6'
      | 'VEHICLE_FLEET_60'
      | 'VEHICLE_61'
      | 'MOTORCYKLE_62'
      | 'MACHINE_63'
      | 'TRAILER_64'
      | 'PERSON_GROUP_65'
      | 'PERSON_66'
      | 'AVIATION_OBJECT_7'
      | 'BUILDING_70'
      | 'CABIN_71'
      | 'ARBEIDSMASKIN_73'
      | 'INVENTORY_74'
      | 'LEISURE_BOAT_75'
      | 'VALUABLES_76'
      | 'ANIMAL_77'
      | 'PLACE_FLEET_78'
      | 'PLACE_8'
      | 'CUMULE_9'
    >,
    vesselType?: string,
    manager?: number,
    owner?: number,
    fleetMarine?: number,
    identification?: string,
    callSignal?: string,
    fromInsuranceYear?: number,
    toInsuranceYear?: number,
    originalInsured?: number,
    fleetObjectNumber?: number,
    majorCode?: number,
    address1?: string,
    address2?: string,
    city?: string,
    flagAreaCode?: string,
    fullText?: string,
    hasInsurancesOnly?: boolean,
    searchHistorical?: boolean,
    orderBy?:
      | 'OBJECT_NUMBER'
      | 'IMO_NUMBER'
      | 'NAME'
      | 'EX_NAME'
      | 'VESSEL_TYPE'
      | 'MANAGER'
      | 'ORIGINAL_BUILT_YEAR',
    orderByDirection?: 'ASC' | 'DESC',
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<SearchResultSimpleInsuredObject>;
  public searchSimple2(
    firstResult?: number,
    maxResults?: number,
    objectNumber?: number,
    name?: string,
    imoNumber?: number,
    types?: Array<
      | 'VESSEL_1'
      | 'RIG_OBJECT_10'
      | 'FLOATING_INSTAL_12'
      | 'LIABILITY_13'
      | 'AQUAOBJECT_14'
      | 'FISH_15'
      | 'AQUA_CARGO_16'
      | 'COASTAL_2'
      | 'CARGO_OBJECT_3'
      | 'ENERGY_PHYSOBJ_4'
      | 'ENERGY_PACKOBJ_5'
      | 'PROPERTY_6'
      | 'VEHICLE_FLEET_60'
      | 'VEHICLE_61'
      | 'MOTORCYKLE_62'
      | 'MACHINE_63'
      | 'TRAILER_64'
      | 'PERSON_GROUP_65'
      | 'PERSON_66'
      | 'AVIATION_OBJECT_7'
      | 'BUILDING_70'
      | 'CABIN_71'
      | 'ARBEIDSMASKIN_73'
      | 'INVENTORY_74'
      | 'LEISURE_BOAT_75'
      | 'VALUABLES_76'
      | 'ANIMAL_77'
      | 'PLACE_FLEET_78'
      | 'PLACE_8'
      | 'CUMULE_9'
    >,
    vesselType?: string,
    manager?: number,
    owner?: number,
    fleetMarine?: number,
    identification?: string,
    callSignal?: string,
    fromInsuranceYear?: number,
    toInsuranceYear?: number,
    originalInsured?: number,
    fleetObjectNumber?: number,
    majorCode?: number,
    address1?: string,
    address2?: string,
    city?: string,
    flagAreaCode?: string,
    fullText?: string,
    hasInsurancesOnly?: boolean,
    searchHistorical?: boolean,
    orderBy?:
      | 'OBJECT_NUMBER'
      | 'IMO_NUMBER'
      | 'NAME'
      | 'EX_NAME'
      | 'VESSEL_TYPE'
      | 'MANAGER'
      | 'ORIGINAL_BUILT_YEAR',
    orderByDirection?: 'ASC' | 'DESC',
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<SearchResultSimpleInsuredObject>>;
  public searchSimple2(
    firstResult?: number,
    maxResults?: number,
    objectNumber?: number,
    name?: string,
    imoNumber?: number,
    types?: Array<
      | 'VESSEL_1'
      | 'RIG_OBJECT_10'
      | 'FLOATING_INSTAL_12'
      | 'LIABILITY_13'
      | 'AQUAOBJECT_14'
      | 'FISH_15'
      | 'AQUA_CARGO_16'
      | 'COASTAL_2'
      | 'CARGO_OBJECT_3'
      | 'ENERGY_PHYSOBJ_4'
      | 'ENERGY_PACKOBJ_5'
      | 'PROPERTY_6'
      | 'VEHICLE_FLEET_60'
      | 'VEHICLE_61'
      | 'MOTORCYKLE_62'
      | 'MACHINE_63'
      | 'TRAILER_64'
      | 'PERSON_GROUP_65'
      | 'PERSON_66'
      | 'AVIATION_OBJECT_7'
      | 'BUILDING_70'
      | 'CABIN_71'
      | 'ARBEIDSMASKIN_73'
      | 'INVENTORY_74'
      | 'LEISURE_BOAT_75'
      | 'VALUABLES_76'
      | 'ANIMAL_77'
      | 'PLACE_FLEET_78'
      | 'PLACE_8'
      | 'CUMULE_9'
    >,
    vesselType?: string,
    manager?: number,
    owner?: number,
    fleetMarine?: number,
    identification?: string,
    callSignal?: string,
    fromInsuranceYear?: number,
    toInsuranceYear?: number,
    originalInsured?: number,
    fleetObjectNumber?: number,
    majorCode?: number,
    address1?: string,
    address2?: string,
    city?: string,
    flagAreaCode?: string,
    fullText?: string,
    hasInsurancesOnly?: boolean,
    searchHistorical?: boolean,
    orderBy?:
      | 'OBJECT_NUMBER'
      | 'IMO_NUMBER'
      | 'NAME'
      | 'EX_NAME'
      | 'VESSEL_TYPE'
      | 'MANAGER'
      | 'ORIGINAL_BUILT_YEAR',
    orderByDirection?: 'ASC' | 'DESC',
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<SearchResultSimpleInsuredObject>>;
  public searchSimple2(
    firstResult?: number,
    maxResults?: number,
    objectNumber?: number,
    name?: string,
    imoNumber?: number,
    types?: Array<
      | 'VESSEL_1'
      | 'RIG_OBJECT_10'
      | 'FLOATING_INSTAL_12'
      | 'LIABILITY_13'
      | 'AQUAOBJECT_14'
      | 'FISH_15'
      | 'AQUA_CARGO_16'
      | 'COASTAL_2'
      | 'CARGO_OBJECT_3'
      | 'ENERGY_PHYSOBJ_4'
      | 'ENERGY_PACKOBJ_5'
      | 'PROPERTY_6'
      | 'VEHICLE_FLEET_60'
      | 'VEHICLE_61'
      | 'MOTORCYKLE_62'
      | 'MACHINE_63'
      | 'TRAILER_64'
      | 'PERSON_GROUP_65'
      | 'PERSON_66'
      | 'AVIATION_OBJECT_7'
      | 'BUILDING_70'
      | 'CABIN_71'
      | 'ARBEIDSMASKIN_73'
      | 'INVENTORY_74'
      | 'LEISURE_BOAT_75'
      | 'VALUABLES_76'
      | 'ANIMAL_77'
      | 'PLACE_FLEET_78'
      | 'PLACE_8'
      | 'CUMULE_9'
    >,
    vesselType?: string,
    manager?: number,
    owner?: number,
    fleetMarine?: number,
    identification?: string,
    callSignal?: string,
    fromInsuranceYear?: number,
    toInsuranceYear?: number,
    originalInsured?: number,
    fleetObjectNumber?: number,
    majorCode?: number,
    address1?: string,
    address2?: string,
    city?: string,
    flagAreaCode?: string,
    fullText?: string,
    hasInsurancesOnly?: boolean,
    searchHistorical?: boolean,
    orderBy?:
      | 'OBJECT_NUMBER'
      | 'IMO_NUMBER'
      | 'NAME'
      | 'EX_NAME'
      | 'VESSEL_TYPE'
      | 'MANAGER'
      | 'ORIGINAL_BUILT_YEAR',
    orderByDirection?: 'ASC' | 'DESC',
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (firstResult !== undefined && firstResult !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>firstResult,
        'firstResult'
      );
    }
    if (maxResults !== undefined && maxResults !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>maxResults,
        'maxResults'
      );
    }
    if (objectNumber !== undefined && objectNumber !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>objectNumber,
        'objectNumber'
      );
    }
    if (name !== undefined && name !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>name,
        'name'
      );
    }
    if (imoNumber !== undefined && imoNumber !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>imoNumber,
        'imoNumber'
      );
    }
    if (types) {
      types.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'types'
        );
      });
    }
    if (vesselType !== undefined && vesselType !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>vesselType,
        'vesselType'
      );
    }
    if (manager !== undefined && manager !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>manager,
        'manager'
      );
    }
    if (owner !== undefined && owner !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>owner,
        'owner'
      );
    }
    if (fleetMarine !== undefined && fleetMarine !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>fleetMarine,
        'fleetMarine'
      );
    }
    if (identification !== undefined && identification !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>identification,
        'identification'
      );
    }
    if (callSignal !== undefined && callSignal !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>callSignal,
        'callSignal'
      );
    }
    if (fromInsuranceYear !== undefined && fromInsuranceYear !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>fromInsuranceYear,
        'fromInsuranceYear'
      );
    }
    if (toInsuranceYear !== undefined && toInsuranceYear !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>toInsuranceYear,
        'toInsuranceYear'
      );
    }
    if (originalInsured !== undefined && originalInsured !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>originalInsured,
        'originalInsured'
      );
    }
    if (fleetObjectNumber !== undefined && fleetObjectNumber !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>fleetObjectNumber,
        'fleetObjectNumber'
      );
    }
    if (majorCode !== undefined && majorCode !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>majorCode,
        'majorCode'
      );
    }
    if (address1 !== undefined && address1 !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>address1,
        'address1'
      );
    }
    if (address2 !== undefined && address2 !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>address2,
        'address2'
      );
    }
    if (city !== undefined && city !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>city,
        'city'
      );
    }
    if (flagAreaCode !== undefined && flagAreaCode !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>flagAreaCode,
        'flagAreaCode'
      );
    }
    if (fullText !== undefined && fullText !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>fullText,
        'fullText'
      );
    }
    if (hasInsurancesOnly !== undefined && hasInsurancesOnly !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>hasInsurancesOnly,
        'hasInsurancesOnly'
      );
    }
    if (searchHistorical !== undefined && searchHistorical !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>searchHistorical,
        'searchHistorical'
      );
    }
    if (orderBy !== undefined && orderBy !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>orderBy,
        'orderBy'
      );
    }
    if (orderByDirection !== undefined && orderByDirection !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>orderByDirection,
        'orderByDirection'
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.get<SearchResultSimpleInsuredObject>(
      `${this.configuration.basePath}/objects/simple`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * @param body
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public update8(
    body?: InsuredObject,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<InsuredObject>;
  public update8(
    body?: InsuredObject,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<InsuredObject>>;
  public update8(
    body?: InsuredObject,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<InsuredObject>>;
  public update8(
    body?: InsuredObject,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Content-Type',
        httpContentTypeSelected
      );
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.put<InsuredObject>(
      `${this.configuration.basePath}/objects`,
      body,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * @param body
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public updateInsuredObjectDetails1(
    body?: InsuredObjectDetails,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<InsuredObjectDetails>;
  public updateInsuredObjectDetails1(
    body?: InsuredObjectDetails,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<InsuredObjectDetails>>;
  public updateInsuredObjectDetails1(
    body?: InsuredObjectDetails,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<InsuredObjectDetails>>;
  public updateInsuredObjectDetails1(
    body?: InsuredObjectDetails,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Content-Type',
        httpContentTypeSelected
      );
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.put<InsuredObjectDetails>(
      `${this.configuration.basePath}/objects/versions/details`,
      body,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * @param body
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public updateMortgagee1(
    body?: Mortgagee,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<Mortgagee>;
  public updateMortgagee1(
    body?: Mortgagee,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<Mortgagee>>;
  public updateMortgagee1(
    body?: Mortgagee,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<Mortgagee>>;
  public updateMortgagee1(
    body?: Mortgagee,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Content-Type',
        httpContentTypeSelected
      );
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.put<Mortgagee>(
      `${this.configuration.basePath}/objects/versions/mortgagees`,
      body,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * @param body
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public updateVersion2(
    body?: InsuredObject,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<InsuredObject>;
  public updateVersion2(
    body?: InsuredObject,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<InsuredObject>>;
  public updateVersion2(
    body?: InsuredObject,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<InsuredObject>>;
  public updateVersion2(
    body?: InsuredObject,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Content-Type',
        httpContentTypeSelected
      );
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.put<InsuredObject>(
      `${this.configuration.basePath}/objects/versions`,
      body,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * @param imoNumber
   * @param objectNumber
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public validateImoNumber1(
    imoNumber?: number,
    objectNumber?: number,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<ImoNumberValidation>;
  public validateImoNumber1(
    imoNumber?: number,
    objectNumber?: number,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<ImoNumberValidation>>;
  public validateImoNumber1(
    imoNumber?: number,
    objectNumber?: number,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<ImoNumberValidation>>;
  public validateImoNumber1(
    imoNumber?: number,
    objectNumber?: number,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (imoNumber !== undefined && imoNumber !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>imoNumber,
        'imoNumber'
      );
    }
    if (objectNumber !== undefined && objectNumber !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>objectNumber,
        'objectNumber'
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.get<ImoNumberValidation>(
      `${this.configuration.basePath}/objects/validateimonumber`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }
}

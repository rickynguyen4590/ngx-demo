/**
 * PARIS API
 * The PARIS API is based on a REST achitecture, and is using JSON as data format.<br/>PARIS API is Stateless, the server does not store any state about the client session on the server side. Statelessness ensures that each service consumer request can be treated independently by the service.<br/>Authentication against the API is done using a combination of Basic Authentication and Token based authentication or API-Keys.<br/><br/>Â©2021 NORIA AS. All Rights Reserved. PARIS is a trademark of <a href=\"http://noria.no/\" target=\"_blank\">NORIA AS</a>.
 *
 * The version of the OpenAPI document: 4.7-202112021325
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional } from '@angular/core';
import {
  HttpClient,
  HttpHeaders,
  HttpParams,
  HttpResponse,
  HttpEvent,
  HttpParameterCodec,
  HttpContext,
} from '@angular/common/http';
import { CustomHttpParameterCodec } from '../encoder';
import { Observable } from 'rxjs';

import { BusinessArea } from '../model/models';
import { CargoType } from '../model/models';
import { Classification } from '../model/models';
import { EnginePropulsion } from '../model/models';
import { EngineType } from '../model/models';
import { HullType } from '../model/models';
import { IceCode } from '../model/models';
import { MajorCode } from '../model/models';
import { Manufacturer } from '../model/models';
import { MaterialType } from '../model/models';
import { MinorCode } from '../model/models';
import { NonmarineMake } from '../model/models';
import { NonmarineModel } from '../model/models';
import { NonmarineSubModel } from '../model/models';
import { ObjectDetailCode } from '../model/models';
import { Shipyard } from '../model/models';
import { TrackItCode } from '../model/models';
import { TransportType } from '../model/models';
import { UsageCode } from '../model/models';
import { VesselCode } from '../model/models';
import { VesselType } from '../model/models';

import { BASE_PATH, COLLECTION_FORMATS } from '../variables';
import { Configuration } from '../configuration';

@Injectable({
  providedIn: 'root',
})
export class SystemCodesObjectCodesService {
  protected basePath = 'http://localhost/noria-dev/rest';
  public defaultHeaders = new HttpHeaders();
  public configuration = new Configuration();
  public encoder: HttpParameterCodec;

  constructor(
    protected httpClient: HttpClient,
    @Optional() @Inject(BASE_PATH) basePath: string,
    @Optional() configuration: Configuration
  ) {
    if (configuration) {
      this.configuration = configuration;
    }
    if (typeof this.configuration.basePath !== 'string') {
      if (typeof basePath !== 'string') {
        basePath = this.basePath;
      }
      this.configuration.basePath = basePath;
    }
    this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
  }

  private addToHttpParams(
    httpParams: HttpParams,
    value: any,
    key?: string
  ): HttpParams {
    if (typeof value === 'object' && value instanceof Date === false) {
      httpParams = this.addToHttpParamsRecursive(httpParams, value);
    } else {
      httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
    }
    return httpParams;
  }

  private addToHttpParamsRecursive(
    httpParams: HttpParams,
    value?: any,
    key?: string
  ): HttpParams {
    if (value == null) {
      return httpParams;
    }

    if (typeof value === 'object') {
      if (Array.isArray(value)) {
        (value as any[]).forEach(
          (elem) =>
            (httpParams = this.addToHttpParamsRecursive(httpParams, elem, key))
        );
      } else if (value instanceof Date) {
        if (key != null) {
          httpParams = httpParams.append(
            key,
            (value as Date).toISOString().substr(0, 10)
          );
        } else {
          throw Error('key may not be null if value is Date');
        }
      } else {
        Object.keys(value).forEach(
          (k) =>
            (httpParams = this.addToHttpParamsRecursive(
              httpParams,
              value[k],
              key != null ? `${key}.${k}` : k
            ))
        );
      }
    } else if (key != null) {
      httpParams = httpParams.append(key, value);
    } else {
      throw Error('key may not be null if value is not object or array');
    }
    return httpParams;
  }

  /**
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getBusinessAreas1(
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<Array<BusinessArea>>;
  public getBusinessAreas1(
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<Array<BusinessArea>>>;
  public getBusinessAreas1(
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<Array<BusinessArea>>>;
  public getBusinessAreas1(
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.get<Array<BusinessArea>>(
      `${this.configuration.basePath}/systemcodes/objectcodes/businessareas`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getCargoTypes1(
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<Array<CargoType>>;
  public getCargoTypes1(
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<Array<CargoType>>>;
  public getCargoTypes1(
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<Array<CargoType>>>;
  public getCargoTypes1(
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.get<Array<CargoType>>(
      `${this.configuration.basePath}/systemcodes/objectcodes/cargotypes`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getClassifications1(
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<Array<Classification>>;
  public getClassifications1(
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<Array<Classification>>>;
  public getClassifications1(
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<Array<Classification>>>;
  public getClassifications1(
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.get<Array<Classification>>(
      `${this.configuration.basePath}/systemcodes/objectcodes/classifications`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getEnginePropulsion1(
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<Array<EnginePropulsion>>;
  public getEnginePropulsion1(
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<Array<EnginePropulsion>>>;
  public getEnginePropulsion1(
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<Array<EnginePropulsion>>>;
  public getEnginePropulsion1(
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.get<Array<EnginePropulsion>>(
      `${this.configuration.basePath}/systemcodes/objectcodes/enginepropulsion`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getEngineTypes1(
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<Array<EngineType>>;
  public getEngineTypes1(
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<Array<EngineType>>>;
  public getEngineTypes1(
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<Array<EngineType>>>;
  public getEngineTypes1(
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.get<Array<EngineType>>(
      `${this.configuration.basePath}/systemcodes/objectcodes/enginetypes`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getHullTypes1(
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<Array<HullType>>;
  public getHullTypes1(
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<Array<HullType>>>;
  public getHullTypes1(
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<Array<HullType>>>;
  public getHullTypes1(
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.get<Array<HullType>>(
      `${this.configuration.basePath}/systemcodes/objectcodes/hulltypes`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getIceCodes1(
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<Array<IceCode>>;
  public getIceCodes1(
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<Array<IceCode>>>;
  public getIceCodes1(
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<Array<IceCode>>>;
  public getIceCodes1(
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.get<Array<IceCode>>(
      `${this.configuration.basePath}/systemcodes/objectcodes/icecodes`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getMajorCodes1(
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<Array<MajorCode>>;
  public getMajorCodes1(
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<Array<MajorCode>>>;
  public getMajorCodes1(
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<Array<MajorCode>>>;
  public getMajorCodes1(
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.get<Array<MajorCode>>(
      `${this.configuration.basePath}/systemcodes/objectcodes/majorcodes`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getManufacturers1(
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<Array<Manufacturer>>;
  public getManufacturers1(
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<Array<Manufacturer>>>;
  public getManufacturers1(
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<Array<Manufacturer>>>;
  public getManufacturers1(
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.get<Array<Manufacturer>>(
      `${this.configuration.basePath}/systemcodes/objectcodes/manufacturers`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * @param objectType
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getMaterialTypes1(
    objectType?:
      | 'VESSEL_1'
      | 'RIG_OBJECT_10'
      | 'FLOATING_INSTAL_12'
      | 'LIABILITY_13'
      | 'AQUAOBJECT_14'
      | 'FISH_15'
      | 'AQUA_CARGO_16'
      | 'COASTAL_2'
      | 'CARGO_OBJECT_3'
      | 'ENERGY_PHYSOBJ_4'
      | 'ENERGY_PACKOBJ_5'
      | 'PROPERTY_6'
      | 'VEHICLE_FLEET_60'
      | 'VEHICLE_61'
      | 'MOTORCYKLE_62'
      | 'MACHINE_63'
      | 'TRAILER_64'
      | 'PERSON_GROUP_65'
      | 'PERSON_66'
      | 'AVIATION_OBJECT_7'
      | 'BUILDING_70'
      | 'CABIN_71'
      | 'ARBEIDSMASKIN_73'
      | 'INVENTORY_74'
      | 'LEISURE_BOAT_75'
      | 'VALUABLES_76'
      | 'ANIMAL_77'
      | 'PLACE_FLEET_78'
      | 'PLACE_8'
      | 'CUMULE_9',
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<Array<MaterialType>>;
  public getMaterialTypes1(
    objectType?:
      | 'VESSEL_1'
      | 'RIG_OBJECT_10'
      | 'FLOATING_INSTAL_12'
      | 'LIABILITY_13'
      | 'AQUAOBJECT_14'
      | 'FISH_15'
      | 'AQUA_CARGO_16'
      | 'COASTAL_2'
      | 'CARGO_OBJECT_3'
      | 'ENERGY_PHYSOBJ_4'
      | 'ENERGY_PACKOBJ_5'
      | 'PROPERTY_6'
      | 'VEHICLE_FLEET_60'
      | 'VEHICLE_61'
      | 'MOTORCYKLE_62'
      | 'MACHINE_63'
      | 'TRAILER_64'
      | 'PERSON_GROUP_65'
      | 'PERSON_66'
      | 'AVIATION_OBJECT_7'
      | 'BUILDING_70'
      | 'CABIN_71'
      | 'ARBEIDSMASKIN_73'
      | 'INVENTORY_74'
      | 'LEISURE_BOAT_75'
      | 'VALUABLES_76'
      | 'ANIMAL_77'
      | 'PLACE_FLEET_78'
      | 'PLACE_8'
      | 'CUMULE_9',
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<Array<MaterialType>>>;
  public getMaterialTypes1(
    objectType?:
      | 'VESSEL_1'
      | 'RIG_OBJECT_10'
      | 'FLOATING_INSTAL_12'
      | 'LIABILITY_13'
      | 'AQUAOBJECT_14'
      | 'FISH_15'
      | 'AQUA_CARGO_16'
      | 'COASTAL_2'
      | 'CARGO_OBJECT_3'
      | 'ENERGY_PHYSOBJ_4'
      | 'ENERGY_PACKOBJ_5'
      | 'PROPERTY_6'
      | 'VEHICLE_FLEET_60'
      | 'VEHICLE_61'
      | 'MOTORCYKLE_62'
      | 'MACHINE_63'
      | 'TRAILER_64'
      | 'PERSON_GROUP_65'
      | 'PERSON_66'
      | 'AVIATION_OBJECT_7'
      | 'BUILDING_70'
      | 'CABIN_71'
      | 'ARBEIDSMASKIN_73'
      | 'INVENTORY_74'
      | 'LEISURE_BOAT_75'
      | 'VALUABLES_76'
      | 'ANIMAL_77'
      | 'PLACE_FLEET_78'
      | 'PLACE_8'
      | 'CUMULE_9',
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<Array<MaterialType>>>;
  public getMaterialTypes1(
    objectType?:
      | 'VESSEL_1'
      | 'RIG_OBJECT_10'
      | 'FLOATING_INSTAL_12'
      | 'LIABILITY_13'
      | 'AQUAOBJECT_14'
      | 'FISH_15'
      | 'AQUA_CARGO_16'
      | 'COASTAL_2'
      | 'CARGO_OBJECT_3'
      | 'ENERGY_PHYSOBJ_4'
      | 'ENERGY_PACKOBJ_5'
      | 'PROPERTY_6'
      | 'VEHICLE_FLEET_60'
      | 'VEHICLE_61'
      | 'MOTORCYKLE_62'
      | 'MACHINE_63'
      | 'TRAILER_64'
      | 'PERSON_GROUP_65'
      | 'PERSON_66'
      | 'AVIATION_OBJECT_7'
      | 'BUILDING_70'
      | 'CABIN_71'
      | 'ARBEIDSMASKIN_73'
      | 'INVENTORY_74'
      | 'LEISURE_BOAT_75'
      | 'VALUABLES_76'
      | 'ANIMAL_77'
      | 'PLACE_FLEET_78'
      | 'PLACE_8'
      | 'CUMULE_9',
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (objectType !== undefined && objectType !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>objectType,
        'objectType'
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.get<Array<MaterialType>>(
      `${this.configuration.basePath}/systemcodes/objectcodes/materialtypes`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getMinorCodes1(
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<Array<MinorCode>>;
  public getMinorCodes1(
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<Array<MinorCode>>>;
  public getMinorCodes1(
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<Array<MinorCode>>>;
  public getMinorCodes1(
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.get<Array<MinorCode>>(
      `${this.configuration.basePath}/systemcodes/objectcodes/minorcodes`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * @param nonmarineMakeCode
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getNonmarineMakeYears1(
    nonmarineMakeCode?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<Array<number>>;
  public getNonmarineMakeYears1(
    nonmarineMakeCode?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<Array<number>>>;
  public getNonmarineMakeYears1(
    nonmarineMakeCode?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<Array<number>>>;
  public getNonmarineMakeYears1(
    nonmarineMakeCode?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (nonmarineMakeCode !== undefined && nonmarineMakeCode !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>nonmarineMakeCode,
        'nonmarineMakeCode'
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.get<Array<number>>(
      `${this.configuration.basePath}/systemcodes/objectcodes/nonmarinemakeyears`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * @param objectType
   * @param year
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getNonmarineMakes1(
    objectType:
      | 'VESSEL_1'
      | 'RIG_OBJECT_10'
      | 'FLOATING_INSTAL_12'
      | 'LIABILITY_13'
      | 'AQUAOBJECT_14'
      | 'FISH_15'
      | 'AQUA_CARGO_16'
      | 'COASTAL_2'
      | 'CARGO_OBJECT_3'
      | 'ENERGY_PHYSOBJ_4'
      | 'ENERGY_PACKOBJ_5'
      | 'PROPERTY_6'
      | 'VEHICLE_FLEET_60'
      | 'VEHICLE_61'
      | 'MOTORCYKLE_62'
      | 'MACHINE_63'
      | 'TRAILER_64'
      | 'PERSON_GROUP_65'
      | 'PERSON_66'
      | 'AVIATION_OBJECT_7'
      | 'BUILDING_70'
      | 'CABIN_71'
      | 'ARBEIDSMASKIN_73'
      | 'INVENTORY_74'
      | 'LEISURE_BOAT_75'
      | 'VALUABLES_76'
      | 'ANIMAL_77'
      | 'PLACE_FLEET_78'
      | 'PLACE_8'
      | 'CUMULE_9',
    year?: number,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<Array<NonmarineMake>>;
  public getNonmarineMakes1(
    objectType:
      | 'VESSEL_1'
      | 'RIG_OBJECT_10'
      | 'FLOATING_INSTAL_12'
      | 'LIABILITY_13'
      | 'AQUAOBJECT_14'
      | 'FISH_15'
      | 'AQUA_CARGO_16'
      | 'COASTAL_2'
      | 'CARGO_OBJECT_3'
      | 'ENERGY_PHYSOBJ_4'
      | 'ENERGY_PACKOBJ_5'
      | 'PROPERTY_6'
      | 'VEHICLE_FLEET_60'
      | 'VEHICLE_61'
      | 'MOTORCYKLE_62'
      | 'MACHINE_63'
      | 'TRAILER_64'
      | 'PERSON_GROUP_65'
      | 'PERSON_66'
      | 'AVIATION_OBJECT_7'
      | 'BUILDING_70'
      | 'CABIN_71'
      | 'ARBEIDSMASKIN_73'
      | 'INVENTORY_74'
      | 'LEISURE_BOAT_75'
      | 'VALUABLES_76'
      | 'ANIMAL_77'
      | 'PLACE_FLEET_78'
      | 'PLACE_8'
      | 'CUMULE_9',
    year?: number,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<Array<NonmarineMake>>>;
  public getNonmarineMakes1(
    objectType:
      | 'VESSEL_1'
      | 'RIG_OBJECT_10'
      | 'FLOATING_INSTAL_12'
      | 'LIABILITY_13'
      | 'AQUAOBJECT_14'
      | 'FISH_15'
      | 'AQUA_CARGO_16'
      | 'COASTAL_2'
      | 'CARGO_OBJECT_3'
      | 'ENERGY_PHYSOBJ_4'
      | 'ENERGY_PACKOBJ_5'
      | 'PROPERTY_6'
      | 'VEHICLE_FLEET_60'
      | 'VEHICLE_61'
      | 'MOTORCYKLE_62'
      | 'MACHINE_63'
      | 'TRAILER_64'
      | 'PERSON_GROUP_65'
      | 'PERSON_66'
      | 'AVIATION_OBJECT_7'
      | 'BUILDING_70'
      | 'CABIN_71'
      | 'ARBEIDSMASKIN_73'
      | 'INVENTORY_74'
      | 'LEISURE_BOAT_75'
      | 'VALUABLES_76'
      | 'ANIMAL_77'
      | 'PLACE_FLEET_78'
      | 'PLACE_8'
      | 'CUMULE_9',
    year?: number,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<Array<NonmarineMake>>>;
  public getNonmarineMakes1(
    objectType:
      | 'VESSEL_1'
      | 'RIG_OBJECT_10'
      | 'FLOATING_INSTAL_12'
      | 'LIABILITY_13'
      | 'AQUAOBJECT_14'
      | 'FISH_15'
      | 'AQUA_CARGO_16'
      | 'COASTAL_2'
      | 'CARGO_OBJECT_3'
      | 'ENERGY_PHYSOBJ_4'
      | 'ENERGY_PACKOBJ_5'
      | 'PROPERTY_6'
      | 'VEHICLE_FLEET_60'
      | 'VEHICLE_61'
      | 'MOTORCYKLE_62'
      | 'MACHINE_63'
      | 'TRAILER_64'
      | 'PERSON_GROUP_65'
      | 'PERSON_66'
      | 'AVIATION_OBJECT_7'
      | 'BUILDING_70'
      | 'CABIN_71'
      | 'ARBEIDSMASKIN_73'
      | 'INVENTORY_74'
      | 'LEISURE_BOAT_75'
      | 'VALUABLES_76'
      | 'ANIMAL_77'
      | 'PLACE_FLEET_78'
      | 'PLACE_8'
      | 'CUMULE_9',
    year?: number,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    if (objectType === null || objectType === undefined) {
      throw new Error(
        'Required parameter objectType was null or undefined when calling getNonmarineMakes1.'
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (objectType !== undefined && objectType !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>objectType,
        'objectType'
      );
    }
    if (year !== undefined && year !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>year,
        'year'
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.get<Array<NonmarineMake>>(
      `${this.configuration.basePath}/systemcodes/objectcodes/nonmarinemakes`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * @param nonmarineMakeCode
   * @param year
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getNonmarineModels1(
    nonmarineMakeCode: string,
    year?: number,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<Array<NonmarineModel>>;
  public getNonmarineModels1(
    nonmarineMakeCode: string,
    year?: number,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<Array<NonmarineModel>>>;
  public getNonmarineModels1(
    nonmarineMakeCode: string,
    year?: number,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<Array<NonmarineModel>>>;
  public getNonmarineModels1(
    nonmarineMakeCode: string,
    year?: number,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    if (nonmarineMakeCode === null || nonmarineMakeCode === undefined) {
      throw new Error(
        'Required parameter nonmarineMakeCode was null or undefined when calling getNonmarineModels1.'
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (nonmarineMakeCode !== undefined && nonmarineMakeCode !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>nonmarineMakeCode,
        'nonmarineMakeCode'
      );
    }
    if (year !== undefined && year !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>year,
        'year'
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.get<Array<NonmarineModel>>(
      `${this.configuration.basePath}/systemcodes/objectcodes/nonmarinemodels`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * @param nonmarineModelCode
   * @param year
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getNonmarineSubModels1(
    nonmarineModelCode: string,
    year: number,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<Array<NonmarineSubModel>>;
  public getNonmarineSubModels1(
    nonmarineModelCode: string,
    year: number,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<Array<NonmarineSubModel>>>;
  public getNonmarineSubModels1(
    nonmarineModelCode: string,
    year: number,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<Array<NonmarineSubModel>>>;
  public getNonmarineSubModels1(
    nonmarineModelCode: string,
    year: number,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    if (nonmarineModelCode === null || nonmarineModelCode === undefined) {
      throw new Error(
        'Required parameter nonmarineModelCode was null or undefined when calling getNonmarineSubModels1.'
      );
    }
    if (year === null || year === undefined) {
      throw new Error(
        'Required parameter year was null or undefined when calling getNonmarineSubModels1.'
      );
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (nonmarineModelCode !== undefined && nonmarineModelCode !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>nonmarineModelCode,
        'nonmarineModelCode'
      );
    }
    if (year !== undefined && year !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>year,
        'year'
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.get<Array<NonmarineSubModel>>(
      `${this.configuration.basePath}/systemcodes/objectcodes/nonmarinesubmodels`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * @param regNo
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getNonmarineSubModelsByRegNo1(
    regNo: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<Array<NonmarineSubModel>>;
  public getNonmarineSubModelsByRegNo1(
    regNo: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<Array<NonmarineSubModel>>>;
  public getNonmarineSubModelsByRegNo1(
    regNo: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<Array<NonmarineSubModel>>>;
  public getNonmarineSubModelsByRegNo1(
    regNo: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    if (regNo === null || regNo === undefined) {
      throw new Error(
        'Required parameter regNo was null or undefined when calling getNonmarineSubModelsByRegNo1.'
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.get<Array<NonmarineSubModel>>(
      `${
        this.configuration.basePath
      }/systemcodes/objectcodes/nonmarinesubmodels/car/${encodeURIComponent(
        String(regNo)
      )}`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getObjectDetailCodes1(
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<Array<ObjectDetailCode>>;
  public getObjectDetailCodes1(
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<Array<ObjectDetailCode>>>;
  public getObjectDetailCodes1(
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<Array<ObjectDetailCode>>>;
  public getObjectDetailCodes1(
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.get<Array<ObjectDetailCode>>(
      `${this.configuration.basePath}/systemcodes/objectcodes/objectdetailcodes`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getShipyards1(
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<Array<Shipyard>>;
  public getShipyards1(
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<Array<Shipyard>>>;
  public getShipyards1(
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<Array<Shipyard>>>;
  public getShipyards1(
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.get<Array<Shipyard>>(
      `${this.configuration.basePath}/systemcodes/objectcodes/shipyards`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getTrackItCodes1(
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<Array<TrackItCode>>;
  public getTrackItCodes1(
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<Array<TrackItCode>>>;
  public getTrackItCodes1(
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<Array<TrackItCode>>>;
  public getTrackItCodes1(
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.get<Array<TrackItCode>>(
      `${this.configuration.basePath}/systemcodes/objectcodes/trackitcodes`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getTransportTypes1(
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<Array<TransportType>>;
  public getTransportTypes1(
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<Array<TransportType>>>;
  public getTransportTypes1(
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<Array<TransportType>>>;
  public getTransportTypes1(
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.get<Array<TransportType>>(
      `${this.configuration.basePath}/systemcodes/objectcodes/transporttypes`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * @param objectType
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getUsageCodes1(
    objectType?:
      | 'VESSEL_1'
      | 'RIG_OBJECT_10'
      | 'FLOATING_INSTAL_12'
      | 'LIABILITY_13'
      | 'AQUAOBJECT_14'
      | 'FISH_15'
      | 'AQUA_CARGO_16'
      | 'COASTAL_2'
      | 'CARGO_OBJECT_3'
      | 'ENERGY_PHYSOBJ_4'
      | 'ENERGY_PACKOBJ_5'
      | 'PROPERTY_6'
      | 'VEHICLE_FLEET_60'
      | 'VEHICLE_61'
      | 'MOTORCYKLE_62'
      | 'MACHINE_63'
      | 'TRAILER_64'
      | 'PERSON_GROUP_65'
      | 'PERSON_66'
      | 'AVIATION_OBJECT_7'
      | 'BUILDING_70'
      | 'CABIN_71'
      | 'ARBEIDSMASKIN_73'
      | 'INVENTORY_74'
      | 'LEISURE_BOAT_75'
      | 'VALUABLES_76'
      | 'ANIMAL_77'
      | 'PLACE_FLEET_78'
      | 'PLACE_8'
      | 'CUMULE_9',
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<Array<UsageCode>>;
  public getUsageCodes1(
    objectType?:
      | 'VESSEL_1'
      | 'RIG_OBJECT_10'
      | 'FLOATING_INSTAL_12'
      | 'LIABILITY_13'
      | 'AQUAOBJECT_14'
      | 'FISH_15'
      | 'AQUA_CARGO_16'
      | 'COASTAL_2'
      | 'CARGO_OBJECT_3'
      | 'ENERGY_PHYSOBJ_4'
      | 'ENERGY_PACKOBJ_5'
      | 'PROPERTY_6'
      | 'VEHICLE_FLEET_60'
      | 'VEHICLE_61'
      | 'MOTORCYKLE_62'
      | 'MACHINE_63'
      | 'TRAILER_64'
      | 'PERSON_GROUP_65'
      | 'PERSON_66'
      | 'AVIATION_OBJECT_7'
      | 'BUILDING_70'
      | 'CABIN_71'
      | 'ARBEIDSMASKIN_73'
      | 'INVENTORY_74'
      | 'LEISURE_BOAT_75'
      | 'VALUABLES_76'
      | 'ANIMAL_77'
      | 'PLACE_FLEET_78'
      | 'PLACE_8'
      | 'CUMULE_9',
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<Array<UsageCode>>>;
  public getUsageCodes1(
    objectType?:
      | 'VESSEL_1'
      | 'RIG_OBJECT_10'
      | 'FLOATING_INSTAL_12'
      | 'LIABILITY_13'
      | 'AQUAOBJECT_14'
      | 'FISH_15'
      | 'AQUA_CARGO_16'
      | 'COASTAL_2'
      | 'CARGO_OBJECT_3'
      | 'ENERGY_PHYSOBJ_4'
      | 'ENERGY_PACKOBJ_5'
      | 'PROPERTY_6'
      | 'VEHICLE_FLEET_60'
      | 'VEHICLE_61'
      | 'MOTORCYKLE_62'
      | 'MACHINE_63'
      | 'TRAILER_64'
      | 'PERSON_GROUP_65'
      | 'PERSON_66'
      | 'AVIATION_OBJECT_7'
      | 'BUILDING_70'
      | 'CABIN_71'
      | 'ARBEIDSMASKIN_73'
      | 'INVENTORY_74'
      | 'LEISURE_BOAT_75'
      | 'VALUABLES_76'
      | 'ANIMAL_77'
      | 'PLACE_FLEET_78'
      | 'PLACE_8'
      | 'CUMULE_9',
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<Array<UsageCode>>>;
  public getUsageCodes1(
    objectType?:
      | 'VESSEL_1'
      | 'RIG_OBJECT_10'
      | 'FLOATING_INSTAL_12'
      | 'LIABILITY_13'
      | 'AQUAOBJECT_14'
      | 'FISH_15'
      | 'AQUA_CARGO_16'
      | 'COASTAL_2'
      | 'CARGO_OBJECT_3'
      | 'ENERGY_PHYSOBJ_4'
      | 'ENERGY_PACKOBJ_5'
      | 'PROPERTY_6'
      | 'VEHICLE_FLEET_60'
      | 'VEHICLE_61'
      | 'MOTORCYKLE_62'
      | 'MACHINE_63'
      | 'TRAILER_64'
      | 'PERSON_GROUP_65'
      | 'PERSON_66'
      | 'AVIATION_OBJECT_7'
      | 'BUILDING_70'
      | 'CABIN_71'
      | 'ARBEIDSMASKIN_73'
      | 'INVENTORY_74'
      | 'LEISURE_BOAT_75'
      | 'VALUABLES_76'
      | 'ANIMAL_77'
      | 'PLACE_FLEET_78'
      | 'PLACE_8'
      | 'CUMULE_9',
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (objectType !== undefined && objectType !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>objectType,
        'objectType'
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.get<Array<UsageCode>>(
      `${this.configuration.basePath}/systemcodes/objectcodes/usagecodes`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getVesselCodes1(
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<Array<VesselCode>>;
  public getVesselCodes1(
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<Array<VesselCode>>>;
  public getVesselCodes1(
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<Array<VesselCode>>>;
  public getVesselCodes1(
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.get<Array<VesselCode>>(
      `${this.configuration.basePath}/systemcodes/objectcodes/vesselcodes`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }

  /**
   * @param objectType
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getVesselTypes1(
    objectType?:
      | 'VESSEL_1'
      | 'RIG_OBJECT_10'
      | 'FLOATING_INSTAL_12'
      | 'LIABILITY_13'
      | 'AQUAOBJECT_14'
      | 'FISH_15'
      | 'AQUA_CARGO_16'
      | 'COASTAL_2'
      | 'CARGO_OBJECT_3'
      | 'ENERGY_PHYSOBJ_4'
      | 'ENERGY_PACKOBJ_5'
      | 'PROPERTY_6'
      | 'VEHICLE_FLEET_60'
      | 'VEHICLE_61'
      | 'MOTORCYKLE_62'
      | 'MACHINE_63'
      | 'TRAILER_64'
      | 'PERSON_GROUP_65'
      | 'PERSON_66'
      | 'AVIATION_OBJECT_7'
      | 'BUILDING_70'
      | 'CABIN_71'
      | 'ARBEIDSMASKIN_73'
      | 'INVENTORY_74'
      | 'LEISURE_BOAT_75'
      | 'VALUABLES_76'
      | 'ANIMAL_77'
      | 'PLACE_FLEET_78'
      | 'PLACE_8'
      | 'CUMULE_9',
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<Array<VesselType>>;
  public getVesselTypes1(
    objectType?:
      | 'VESSEL_1'
      | 'RIG_OBJECT_10'
      | 'FLOATING_INSTAL_12'
      | 'LIABILITY_13'
      | 'AQUAOBJECT_14'
      | 'FISH_15'
      | 'AQUA_CARGO_16'
      | 'COASTAL_2'
      | 'CARGO_OBJECT_3'
      | 'ENERGY_PHYSOBJ_4'
      | 'ENERGY_PACKOBJ_5'
      | 'PROPERTY_6'
      | 'VEHICLE_FLEET_60'
      | 'VEHICLE_61'
      | 'MOTORCYKLE_62'
      | 'MACHINE_63'
      | 'TRAILER_64'
      | 'PERSON_GROUP_65'
      | 'PERSON_66'
      | 'AVIATION_OBJECT_7'
      | 'BUILDING_70'
      | 'CABIN_71'
      | 'ARBEIDSMASKIN_73'
      | 'INVENTORY_74'
      | 'LEISURE_BOAT_75'
      | 'VALUABLES_76'
      | 'ANIMAL_77'
      | 'PLACE_FLEET_78'
      | 'PLACE_8'
      | 'CUMULE_9',
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpResponse<Array<VesselType>>>;
  public getVesselTypes1(
    objectType?:
      | 'VESSEL_1'
      | 'RIG_OBJECT_10'
      | 'FLOATING_INSTAL_12'
      | 'LIABILITY_13'
      | 'AQUAOBJECT_14'
      | 'FISH_15'
      | 'AQUA_CARGO_16'
      | 'COASTAL_2'
      | 'CARGO_OBJECT_3'
      | 'ENERGY_PHYSOBJ_4'
      | 'ENERGY_PACKOBJ_5'
      | 'PROPERTY_6'
      | 'VEHICLE_FLEET_60'
      | 'VEHICLE_61'
      | 'MOTORCYKLE_62'
      | 'MACHINE_63'
      | 'TRAILER_64'
      | 'PERSON_GROUP_65'
      | 'PERSON_66'
      | 'AVIATION_OBJECT_7'
      | 'BUILDING_70'
      | 'CABIN_71'
      | 'ARBEIDSMASKIN_73'
      | 'INVENTORY_74'
      | 'LEISURE_BOAT_75'
      | 'VALUABLES_76'
      | 'ANIMAL_77'
      | 'PLACE_FLEET_78'
      | 'PLACE_8'
      | 'CUMULE_9',
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<HttpEvent<Array<VesselType>>>;
  public getVesselTypes1(
    objectType?:
      | 'VESSEL_1'
      | 'RIG_OBJECT_10'
      | 'FLOATING_INSTAL_12'
      | 'LIABILITY_13'
      | 'AQUAOBJECT_14'
      | 'FISH_15'
      | 'AQUA_CARGO_16'
      | 'COASTAL_2'
      | 'CARGO_OBJECT_3'
      | 'ENERGY_PHYSOBJ_4'
      | 'ENERGY_PACKOBJ_5'
      | 'PROPERTY_6'
      | 'VEHICLE_FLEET_60'
      | 'VEHICLE_61'
      | 'MOTORCYKLE_62'
      | 'MACHINE_63'
      | 'TRAILER_64'
      | 'PERSON_GROUP_65'
      | 'PERSON_66'
      | 'AVIATION_OBJECT_7'
      | 'BUILDING_70'
      | 'CABIN_71'
      | 'ARBEIDSMASKIN_73'
      | 'INVENTORY_74'
      | 'LEISURE_BOAT_75'
      | 'VALUABLES_76'
      | 'ANIMAL_77'
      | 'PLACE_FLEET_78'
      | 'PLACE_8'
      | 'CUMULE_9',
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: '*/*'; context?: HttpContext }
  ): Observable<any> {
    let localVarQueryParameters = new HttpParams({ encoder: this.encoder });
    if (objectType !== undefined && objectType !== null) {
      localVarQueryParameters = this.addToHttpParams(
        localVarQueryParameters,
        <any>objectType,
        'objectType'
      );
    }

    let localVarHeaders = this.defaultHeaders;

    let localVarCredential: string | undefined;
    // authentication (Authorization) required
    localVarCredential = this.configuration.lookupCredential('Authorization');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'Authorization',
        localVarCredential
      );
    }

    // authentication (paris-api-key) required
    localVarCredential = this.configuration.lookupCredential('paris-api-key');
    if (localVarCredential) {
      localVarHeaders = localVarHeaders.set(
        'paris-api-key',
        localVarCredential
      );
    }

    let localVarHttpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept;
    if (localVarHttpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['*/*'];
      localVarHttpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts);
    }
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      );
    }

    let localVarHttpContext: HttpContext | undefined =
      options && options.context;
    if (localVarHttpContext === undefined) {
      localVarHttpContext = new HttpContext();
    }

    let responseType_: 'text' | 'json' = 'json';
    if (
      localVarHttpHeaderAcceptSelected &&
      localVarHttpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text';
    }

    return this.httpClient.get<Array<VesselType>>(
      `${this.configuration.basePath}/systemcodes/objectcodes/vesseltypes`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: localVarHeaders,
        observe: observe,
        reportProgress: reportProgress,
      }
    );
  }
}
